引发异常时编译器总是会创建一个临时拷贝，即使异常规范和catch块中指定的是引用。指针将指向对象的副本。这样可以防止**栈解退**过程原对象被释放。
使用引用的原因是基类引用可以执行派生类对象。

**catch(...)捕获所有异常**

在用`catch`块捕获异常时，应按照从**具体**（派生类）到**一般**（基类或`catch(...)`）的顺序防止逻辑错误

---

### **核心概念**
C++异常处理基于 **`try`、`throw`、`catch`** 三个关键字，用于分离正常逻辑与错误处理，避免代码被大量`if-else`嵌套。

---

### **1. 抛出异常（throw）**
- **作用**：当检测到错误时，用`throw`抛出任意类型的对象（推荐使用标准异常类或自定义类）。
- 析构函数中抛出异常可能导致资源未释放或程序直接终止
- **重新抛出**：在`catch`块中使用`throw;`（不跟任何表达式）可以重新抛出当前捕获的异常对象，允许外层 `try/catch` 进一步处理它。异常类型转换需要显式`throw NewException`
- **示例**：
  ```cpp
  double divide(int a, int b) {
      if (b == 0) {
          throw std::runtime_error("除数不能为0！"); // 抛出一个标准异常对象
      }
      return static_cast<double>(a) / b;
  }
  ```

---

### **2. 捕获异常（try-catch）**
- **结构**：
  ```cpp
  try {
      // 可能抛出异常的代码
  } catch (异常类型1& e) {
      // 处理类型1的异常
  } catch (异常类型2& e) {
      // 处理类型2的异常
  } catch (...) { 
      // 捕获所有未处理的异常（不推荐滥用）
  }
  ```
- **示例**：
  ```cpp
  try {
      double result = divide(10, 0);
  } catch (const std::runtime_error& e) {
      std::cerr << "错误信息: " << e.what() << std::endl;
  }
  ```

---

### **3. 标准异常类**
- C++标准库提供了一系列异常类（定义在`<stdexcept>`）：
  - `std::exception`异常类基类，可用于自定义异常类继承
  - `std::runtime_error`：运行时错误（如无效输入）
  - `std::logic_error`：逻辑错误（如越界访问）
  - 其他派生类：`std::out_of_range`, `std::invalid_argument`等
- **自定义异常**：
  ```cpp
  class MyException : public std::exception {
  public:
      const char* what() const noexcept override {
          return "这是我的自定义异常！";
      }
  };
  ```

---

### **4. 异常安全与最佳实践**
- **RAII原则**：利用构造函数获取资源、析构函数释放资源，避免资源泄漏（如智能指针）。
- **不要滥用异常**：
  - 异常应用于 **不可恢复的错误**（如文件不存在），而非控制正常流程。
  - 避免在析构函数中抛出异常（可能导致程序终止）。
- **明确异常规范**：
  - C++11起用`noexcept`声明不会抛异常的函数：
	（常用于析构函数和性能敏感代码）
    ```cpp
    void safeFunction() noexcept { ... }
    ```

---

### **5. 栈展开（Stack Unwinding）**
- 当异常被抛出时，程序会 **从当前函数向上回溯调用栈**，直到找到匹配的`catch`块。在此过程中，局部对象会被正确析构。

---

```cpp
#include <iostream>
#include <stdexcept>

void readFile(const std::string& filename) {
    if (filename.empty()) {
        throw std::invalid_argument("文件名不能为空！");
    }
    // 模拟文件读取失败
    throw std::runtime_error("文件打开失败");
}

int main() {
    try {
        readFile("");
    } catch (const std::invalid_argument& e) {
        std::cout << "参数错误: " << e.what() << std::endl;
    } catch (const std::exception& e) { // 捕获所有派生自exception的异常
        std::cout << "其他错误: " << e.what() << std::endl;
    }
    return 0;
}
```

---


