```
#include <iostream>
using namespace std;

template <class T>
class Array
{
	int m_Cap;
	int m_Size;
	T* m_PA;
public:
	Array(int c)
	{
		cout << "有参构造" << endl;
		this->m_Cap = c;
		this->m_Size = 0;
		m_PA = new T[m_Cap];
	}
	Array(const Array& ar)
	{
		cout << "拷贝构造" << endl;
		this->m_Cap = ar.m_Cap;
		this->m_Size = ar.m_Size;
		this->m_PA = new T[ar.m_Cap];
		for (int i = 0; i < this->m_Size; i++)
		{
			this->m_PA[i] = ar.m_PA[i];
		}
	}
	Array& operator=(Array& a1)
	{
		cout << "=重载" << endl;
		if (this->m_PA != nullptr) //若堆区有数据，释放
		{
			delete[] this->m_PA;
			this->m_PA = nullptr;
			this->m_Cap = 0;
			this->m_Size = 0;
		}
		this->m_Cap = a1.m_Cap;
		this->m_Size = a1.m_Size;
		this->m_PA = new T(*a1.m_PA);
		for (int i = 0; i < this->m_Size; i++)
		{
			this->m_PA[i] = a1.m_PA[i];
		}
		return  *this;
	}
	T& operator[](int i)
	{
		return this->m_PA[i];
	}
	void Push_Back(const T& n)
	{
		if (this->m_Cap == this->m_Size)
			return;
		this->m_PA[this->m_Size] = n;
		m_Size++;
	}
	void Pop_Back()
	{
		if (this->m_Size == 0) //逻辑删除，print函数依据m_Size访问
			return;
		this->m_Size--;
	}
	int getSize()
	{
		return m_Size;
	}
	int getCap()
	{
		return m_Cap;
	}
	~Array()
	{
		cout << "析构" << endl;
		if (this->m_PA != nullptr)
		{
			delete[] this->m_PA;
			this->m_PA = nullptr;
		}
	}
};

void print(Array<int>& a)
{
	for (int i = 0; i < a.getSize(); i++)
	{
		cout << a[i] << endl;
	}
}

class Person
{
private:
	string m_Name;
	int m_Age;
public:
	Person() {}; //开辟堆区空间时使用了无参构造，默认无参构造被有参构造覆盖
	Person(string n, int a)
	{
		this->m_Name = n;
		this->m_Age = a;
	}
	void printPerson()
	{
		cout << m_Name << ' ' << m_Age << endl;
	}
};

int main()
{
	Array<int> a1(5);
	for (int i = 0; i < 5; i++)
		a1.Push_Back(i);
	Array<int> a2(a1);
	a2.Pop_Back();
	Array<int> a3 = a2;
	print(a3);
	Array<Person> a4(3);
	Person p1("awa", 10);
	Person p2("qaq", 20);
	Person p3("owo", 40);
	a4.Push_Back(p1);
	a4.Push_Back(p2);
	a4.Push_Back(p3);
	for (int i = 0; i < 3; i++)
	{
		a4[i].printPerson();
	}
	
	return 0;
}
```