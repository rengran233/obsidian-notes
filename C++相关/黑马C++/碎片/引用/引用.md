int a = 10;
int &b = a; //&不是地址运算符，类似int *


**引用必须初始化**（绑定），初始化后指向对象不可改变，不同于指针
（相当于指针常量int * const p）
int &b //未初始化，不可


引用传递，形参可修饰实参
```
void swap(int &a, int &b){
	int temp;
	temp = a;
	a = b;
	b = temp
}
int main(){
	int a = 10;
	int b = 20;
	swap(a, b);
	cout << a << b <<endl; //输出2010
}
```
使用引用传递可以像地址传递（使用指针）一样修饰实参，并且避免像值传递复制整个对象（如包含多个成员的类）从而降低效率。


int & a = 10 //不可行
const int & a = 10 //可行，生成中间变量temp

函数参数列表使用引用不能接受字面量（非常量引用的初始值必须为**可修改的左值**），但用常量引用可以。因为字面量是临时值，传入字面量可能**修改临时值**，而且临时值（右值）本身无法**取地址**；而用`const`修饰后**不可改变**，所以可以传入
```cpp
void func1(int& x) {x = 42}; //无意义且危险，不允许
void func2(const int&) {};
int main() {
//func1(10);
func2(20);}
```


常量引用，修饰形参防止误操作
```
void showValue(const int & val){
	val = 1000; //不可行，常量引用不可修改
	cout << val << endl;
}
int main(){
	int a = 10;
	showValue(a);
}
```


**返回引用**
函数返回引用可以避免返回值的拷贝操作，引用相当于别名，避免创建一个副本