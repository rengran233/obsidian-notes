关键字friend，允许访问类私有成员
以下对象可以被声明为友元：全局函数，类，成员函数
友元函数是**非成员函数**，但可以访问类的私有成员。需在**类内声明，类外定义**。
```cpp
#include <iostream>
#include <string>
using namespace std;
class Building
{
	friend void visit(Building* house);
	friend class Goodgay; //友元声明
	string m_BedRoom;
	string m_SittingRoom;
public:
	Building()
	{
		m_BedRoom = "Bed room";
		m_SittingRoom = "Sitting room";
		cout << "House is initialized." << endl;
	}
};
void visit(Building *house) //全局函数友元
{
	cout << house->m_BedRoom << endl;
}
class Goodgay //类友元
{
	Building* house02;
public:
	Goodgay()
	{
		house02 = new Building; //指针初始化
	}
	void visit02()
	{
		cout << house02->m_SittingRoom << endl;
	}
};
int main()
{
	Building house;
	visit(&house);
	Goodgay gg;
	gg.visit02();
	return 0;
}
```


友元函数也可以在类的内部定义，但此时它被视为**全局作用域的内联函数**，而非类的成员函数。
### **详细解释**

1. **友元函数的基本概念**  
   友元函数（Friend Function）是一种被类授予访问其私有（`private`）和保护（`protected`）成员权限的**非成员函数**。其特点如下：  
   - **声明在类内**：通过 `friend` 关键字在类内部声明。  
   - **定义位置灵活**：可以在类内或类外定义。  
   - **作用域**：友元函数属于全局或命名空间作用域，而非类的成员。

2. **在类内部定义友元函数**  
   ```cpp
   class MyClass {
   private:
       int secret;
   public:
       // 友元函数在类内部定义
       friend void showSecret(MyClass obj) {
           std::cout << obj.secret; // 直接访问私有成员
       }
   };
   ```
   - **特性**：  
     - 函数 `showSecret` 在类内定义，但它是全局函数。  
     - 默认具有 **内联（`inline`）** 属性，可能被编译器优化。  
     - 必须在使用前声明或定义，否则可能引发链接错误。

3. **注意事项**  
   - **作用域与可见性**：  
     - 即使定义在类内部，友元函数的作用域仍为全局，需通过参数访问类的实例。  
     - 若未在类外提供声明，其他代码可能无法直接调用该友元函数。  
     ```cpp
     // 需要在类外声明友元函数（否则可能无法调用）
     void showSecret(MyClass obj); // 前向声明
     ```
   - **隐式内联**：  
     - 在类内部定义的友元函数会被隐式标记为 `inline`，适用于短小的工具函数。  
   - **访问权限的局限性**：  
     - 友元函数只能通过参数或全局对象访问类的成员，无法直接使用类的 `this` 指针。

4. **对比类外定义**  
   ```cpp
   class MyClass {
   private:
       int secret;
   public:
       friend void showSecret(MyClass obj); // 类内声明
   };

   // 类外定义
   void showSecret(MyClass obj) {
       std::cout << obj.secret;
   }
   ```
   - **优点**：  
     - 类外定义更清晰，符合代码分离原则。  
     - 避免隐式内联可能导致的代码膨胀。  
   - **缺点**：  
     - 需要额外维护声明与定义的一致性。

---

### **适用场景**
- **工具函数**：需要访问类私有数据的全局辅助函数（如运算符重载）。  
  ```cpp
  class Vector {
  public:
      int x, y;
      friend Vector operator+(const Vector& a, const Vector& b) {
          return {a.x + b.x, a.y + b.y}; // 内联友元运算符
      }
  };
  ```
- **简化代码**：短小的函数直接在类内实现，减少文件切换。

---

### **总结**
| **特性**               | **类内定义友元函数**                  | **类外定义友元函数**          |
|------------------------|-------------------------------------|-----------------------------|
| **作用域**             | 全局函数                            | 全局函数                     |
| **内联性**             | 隐式内联                            | 可显式标记 `inline`          |
| **代码组织**           | 紧耦合，适合简单逻辑                | 松耦合，适合复杂逻辑         |
| **可见性**             | 需前向声明                          | 需类内声明和类外定义         |
| **典型用例**           | 运算符重载、小型工具函数            | 需要分离声明的复杂函数       |

**建议**：  
- 优先在类外定义友元函数，除非函数逻辑非常简单且需要内联优化。  
- 避免滥用友元函数，以保持类的封装性。




友元关系不可被**继承**


通过在基类中声明派生类为友元，可以让派生类能够通过成员函数访问基类的**私有成员**。（但也不能直接访问）