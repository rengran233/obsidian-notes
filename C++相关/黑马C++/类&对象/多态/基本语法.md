静态多态：通过函数重载和运算符**重载和模板**实现；函数地址早绑定，在编译阶段确定
动态多态：**继承和虚函数**实现运行时多态；函数地址晚绑定，在运行阶段确定


```cpp
#include <iostream>
using namespace std;

class Animal
{
public:
	void speak() 
	{
		cout << "Animal is speaking." << endl;
	}
};

class Plant
{
public:
	virtual void speak() //virtual虚函数，晚绑定
	{
		cout << "Plant is speaking." << endl;
	}
};

class Cat :public Animal
{
public:
	void speak()
	{
		cout << "Cat is speaking." << endl;
	}
};

class Tree :public Plant
{
public:
	void speak()
	{
		cout << "Tree is speaking." << endl;
	}
};

void doSpeak(Animal &a) //父类和子类可以相互转换
{
	a.speak();
}

void doSpeak(Plant& p)
{
	p.speak();
}

void test01()
{
	Cat c;
	Tree t;
	doSpeak(c); //Animal is speaking
	doSpeak(t); //Tree is speaking
}

int main()
{
	test01();
	return 0;
}
```
调用该函数时总是会调用定义在当前类中的版本，而不是派生类中可能重写的版本。
而动态多态根据传入**对象的实际类型**调用相应函数


多态的条件：
1.有继承关系
2.子类对父类进行重写

动态多态的使用：
父类的指针或引用执行子类对象


**赋值兼容规则的核心**：派生类可以向基类“向上转型”，反之则需强制转换且风险高。