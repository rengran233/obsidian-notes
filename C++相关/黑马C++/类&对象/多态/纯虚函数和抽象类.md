纯虚函数：`virtual <数据类型> <函数名> (参数列表) = 0`
抽象类：有纯虚函数的类称为抽象类
抽象类的特点：
1.无法实例化对象
2.抽象类的子类必须重写抽象类的纯虚函数，否则也属于抽象类


## 抽象类的构造函数：

1. **构造函数的存在意义**  
   抽象类虽然不能被实例化，但它的构造函数会**被派生类调用**。通过构造函数可以初始化抽象类中定义的成员变量，例如：
   ```cpp
   class Shape { // 抽象类
   protected:
       string color;
   public:
       Shape(string c) : color(c) {} // 构造函数
       virtual void draw() = 0;      // 纯虚函数
   };
   ```

2. **构造函数的调用时机**  
   当创建派生类对象时，会**先调用抽象基类的构造函数**，再调用派生类的构造函数：
   ```cpp
   class Circle : public Shape {
       double radius;
   public:
       Circle(string c, double r) 
           : Shape(c), radius(r) {} // 先调用基类构造函数
       void draw() override { /*...*/ }
   };
   ```

3. **特殊注意事项**  
   - 抽象类的构造函数**不能是纯虚函数**  
   - 建议将抽象类的析构函数声明为虚函数（`virtual ~Shape() = default;`）  
   - C++11起支持为纯虚函数提供默认实现（但构造函数不适用此规则）



## 抽象类的析构函数：

### **1. 必须声明为虚函数**
- **多态安全**：当通过基类指针删除派生类对象时，若基类析构函数不是虚函数，可能导致派生类的析构函数未被调用，引发内存泄漏。  
- **示例**：  
  ```cpp
  class Shape {  // 抽象类
  public:
      virtual ~Shape() = default;  // ✅ 虚析构函数
      virtual void draw() = 0;     // 纯虚函数
  };
  ```

---

### **2. 纯虚析构函数的特殊处理**
- **允许声明纯虚析构函数**，但**必须提供实现**（即使=0也要定义）：  
- 当派生类对象被销毁时，会**自动调用基类的析构函数**。即使基类析构函数是纯虚的，编译器仍需找到其实现来完成销毁链，否则会导致**链接错误**。简单来说，析构函数的特殊性在于它需要被**隐式调用**，而普通纯虚函数只需由派生类覆盖。
  ```cpp
  class AbstractBase {
  public:
      virtual ~AbstractBase() = 0; // 声明纯虚析构函数
  }
  // 必须提供实现（否则链接错误）
  AbstractBase::~AbstractBase() {}
  ```

---

### **3. 派生类的析构责任**
- 派生类析构函数会**自动调用基类析构函数**，无需显式调用。  
- 示例：  
  ```cpp
  class Circle : public Shape {
  public:
      ~Circle() override { /* 清理派生类资源 */ }
      void draw() override { /* 实现纯虚函数 */ }
  };
  ```

---

### **总结**
- **虚析构函数**：确保多态删除时的正确析构顺序。  
- **纯虚析构需定义**：避免链接错误。  
- **资源管理**：派生类应负责自身资源的释放。
