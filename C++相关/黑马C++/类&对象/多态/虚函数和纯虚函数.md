😊 当基类的析构函数不是虚函数时，通过基类指针删除派生类对象会导致**派生类的析构函数不被调用**，这是因为：

1. **静态绑定机制**  
   如果基类析构函数非虚，编译器根据指针的静态类型（基类类型）决定调用哪个析构函数。即使指针实际指向派生类对象，也只会调用基类的析构函数。

2. **析构链断裂**  
   C++的对象析构顺序是：**派生类析构 → 基类析构**。若基类析构函数未声明为虚函数，派生类的析构函数会被跳过，导致：
   - 派生类中动态分配的内存泄漏
   - 文件句柄、网络连接等资源未释放

---

### **示例说明**
```cpp
class Base {
public:
    ~Base() { cout << "Base析构" << endl; } // ❌ 非虚析构
};

class Derived : public Base {
public:
    ~Derived() { cout << "Derived析构" << endl; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;  // 仅输出 "Base析构"
    return 0;
}
```

---

### **解决方案**
将基类析构函数声明为虚函数，触发动态绑定：
```cpp
virtual ~Base() { cout << "Base析构" << endl; } // ✅ 虚析构
```
此时 `delete ptr` 会正确调用 `Derived` 和 `Base` 的析构函数，形成完整析构链~ 🚀





## 纯虚函数区别于虚函数：强制规范
### **1. 定义抽象基类（接口类）**
当基类**无法提供合理的默认实现**，且必须要求所有派生类自行实现该函数时，需用纯虚函数。  
**示例**：  
```cpp
class Shape {  // 抽象基类
public:
    virtual double area() = 0; // 纯虚函数：所有形状必须能计算面积
};

class Circle : public Shape {
    double radius;
public:
    double area() override { 
        return 3.14 * radius * radius; 
    }
};
```

---

### **2. 强制派生类遵守协议**
在框架或库设计中，若基类需要为派生类定义**必须遵守的行为规范**，纯虚函数能确保接口的统一性。  
**示例**：  
```cpp
class DataProcessor {  // 数据处理框架基类
public:
    virtual void validate() = 0; // 所有数据处理必须实现验证逻辑
    virtual void transform() = 0; 
};

class CSVProcessor : public DataProcessor {
    void validate() override { /* CSV格式验证 */ }
    void transform() override { /* 数据转换 */ }
};
```

---

### **3. 设计模式中的接口隔离**
在模板方法、策略模式等设计模式中，纯虚函数用于定义算法骨架或策略接口。  
**示例**：  
```cpp
class SortStrategy {  // 排序策略接口
public:
    virtual void sort(vector<int>& data) = 0; 
};

class QuickSort : public SortStrategy {
    void sort(vector<int>& data) override { /* 快排实现 */ }
};
```

---

### **关键总结**
- **纯虚函数**：强制派生类实现，基类不可实例化。  
- **普通虚函数**：提供默认逻辑，派生类可选择是否覆盖。  
- 虚函数和纯虚函数都可以实现多态，使用纯虚函数更多出于规范考虑



## 虚函数和修饰符：
- 虚函数和`static`：虚函数不能用`static`修饰，因为`static` 成员函数属于类而非对象，**无法通过对象指针/引用实现多态**，因此不能声明为虚函数。
- 虚函数和`const`：虚函数可以用`const`修饰，并且和非常函数构成重载。




