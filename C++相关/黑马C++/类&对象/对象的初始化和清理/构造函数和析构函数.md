构造函数（成员初始化）和析构函数（清理），系统自动调用。如果没有编写，编译器会执行空实现。

**构造函数：** 类名(){}
1.不需要声明类型，也没有返回值。
2.可以有参数，也可以发生重载
3.系统会调用且仅调用一次

**析构函数：** ~类名(){}
1.不需要声明类型，也没有返回值
2.没有参数，不能重载，仅有一个
3.对象在销毁前系统会调用且仅调用一次

构造和析构函数不能被**调用**，也不能被**继承**或**取地址**


## 构造析构和修饰词：

### **1. 构造函数（Constructor）**
- **允许的修饰符**：
  - **`explicit`**：防止隐式类型转换（如单参数构造函数）。
    ```cpp
    class Example {
    public:
        explicit Example(int x) {} // 显式构造函数
    };
    ```
  - **访问修饰符**（如 `public`、`private`、`protected`）：控制构造函数的作用域。

- **不允许的修饰符**：
  - **`const` 或 `volatile`**：构造函数需要初始化对象，不能假定对象状态。
  - **`static`**：构造函数属于对象实例化过程，不能是静态的。

---

### **2. 析构函数（Destructor）**
- **允许的修饰符**：
  - **`virtual`**：用于多态基类，确保正确调用派生类析构函数。
    ```cpp
    class Base {
    public:
        virtual ~Base() {} // 虚析构函数
    };
    ```
  - **访问修饰符**：通常为 `public`，但可设为 `protected`/`private`（需谨慎设计）。

- **不允许的修饰符**：
  - **`const` 或 `volatile`**：析构函数需要修改对象状态（如释放资源）。
  - **`static`**：析构函数与对象生命周期绑定，不能是静态的。

---

### **总结**
- **构造函数**：支持 `explicit` 和访问控制，不支持 `const`/`volatile`/`static`。  
- **析构函数**：支持 `virtual` 和访问控制，不支持 `const`/`volatile`/`static`。  

如果有具体使用场景或代码疑问，欢迎继续交流~ 🚀
