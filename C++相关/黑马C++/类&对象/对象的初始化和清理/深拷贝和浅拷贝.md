浅拷贝：复制
深拷贝：重新申请一块堆区内存空间

浅拷贝的风险：堆区内存重复释放
```
class Person{
public:
	Person(int height)
	{
		m_height = new int(height);
	}
	// 此时存在默认拷贝构造函数
	~Person()
	{
		if(m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
	}
private:
	int* m_height;
};
void test()
{
	Person p1(180);
	//此时p1已有指针p1.m_height指向180所在地址a
	Person p2(p1); //默认拷贝函数浅拷贝
}
int main()
{
	test();
}
//此时程序会报错，因为默认拷贝构造函数浅拷贝传递值，p2.m_height与p1地址一致，p1析构函数执行后地址a中内存被释放，p2再次释放空地址。
```
如果属性有在堆区开辟，要自己提供拷贝构造函数
```
class Person{
public:
	Person(int height)
	{
		cout << "有参函数被调用" << endl;
		m_height = new int(height);
	}
	Person(const Person &p)
	{
		cout << "拷贝函数被调用" << endl;
		m_height = new int(*p.m_height); //分配新空间
		//m_height = p.m_height默认函数
	}
	~Person()
	{
		cout << "析构函数被调用" <<endl;
		if(m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
	}
private:
	int* m_height;
};
void test()
{
	Person p1(180);
	Person p2(p1);
}
int main()
{
	test();
	return 0;
}
//p1指向地址a，p2指向地址b，指均为180
```