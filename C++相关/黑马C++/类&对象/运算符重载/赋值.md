未重载时`=`执行浅拷贝。如果类中有属性指向堆区，赋值时也会出现深浅拷贝问题
```
//无法运行
#include <iostream>
using namespace std;

class Person
{
public:
	Person(int a)
	{
		m_Age = new int(a);
	}
	~Person()
	{
		if (m_Age != nullptr)
			delete m_Age;
		m_Age = nullptr;
	}
	int *m_Age;
};

int main()
{
	Person p1(10);
	Person p2(20);
	p1 = p2; //浅拷贝
	cout << *p1.m_Age << endl;
	cout << *p2.m_Age << endl;
}
```
此处编译器令`p1.m_Age = p2.m_Age`，指向堆区同一块地址，析构函数释放内存时重复释放报错


```
#include <iostream>
using namespace std;

class Person
{
public:
	Person(int a)
	{
		m_Age = new int(a);
	}
	Person& operator=(Person& p)
	{
		m_Age = new int(*p.m_Age); //在堆区重新开辟一块内存
		return *this; //返回自身，支持链式编程
	}
	~Person()
	{
		if (m_Age != nullptr)
		{
			delete m_Age;
			m_Age = nullptr;
		}
	}
	int *m_Age;
};

int main()
{
	Person p1(10);
	Person p2(20);
	p1 = p2;
	cout << *p1.m_Age << endl;
	cout << *p2.m_Age << endl;
	Person p3(30);
	p1 = p2 = p3;
	cout << *p1.m_Age << endl;
	cout << *p2.m_Age << endl;
	cout << *p3.m_Age << endl;
	return 0;
}
```