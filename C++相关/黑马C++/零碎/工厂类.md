

您提到的代码中并没有显式的工厂类设计，但我们可以基于现有代码的结构，分析如何通过工厂模式优化 `Token` 的创建过程，并探讨其潜在价值。以下是详细分析：

---

### **一、当前代码的 Token 创建方式**
在原代码中，`Token` 的创建是分散在词法分析器（Lexer）中的直接构造，例如：
```cpp
// 创建数值类型的 Token
tokens.push_back({ TokenType::Number, parsed_value, 0 });

// 创建运算符类型的 Token
tokens.push_back({ TokenType::Operator, 0, current_char });
```

#### **存在的问题**
1. **创建逻辑分散**：Token 的构造逻辑分布在多个代码块中，难以统一管理。
2. **可扩展性差**：若需新增 Token 类型（如函数名、变量名），需修改多处代码。
3. **易出错**：手动设置 `value` 和 `op` 字段时需保证与 `TokenType` 匹配，容易遗漏或错误。

---

### **二、工厂模式优化方案**
通过引入 **`TokenFactory` 类**，封装 Token 的创建逻辑。

#### **1. 工厂类定义**
```cpp
class TokenFactory {
public:
    static Token createNumber(double value) {
        return { TokenType::Number, value, 0 };
    }

    static Token createOperator(char op) {
        return { TokenType::Operator, 0, op };
    }

    static Token createLeftParen() {
        return { TokenType::LeftParen, 0, 0 };
    }

    static Token createRightParen() {
        return { TokenType::RightParen, 0, 0 };
    }
};
```

#### **2. 修改后的 Lexer 代码**
```cpp
// 原代码
tokens.push_back({ TokenType::Number, parsed_value, 0 });

// 修改后
tokens.push_back(TokenFactory::createNumber(parsed_value));
```

---

### **三、工厂模式的优势**
#### **1. 集中管理创建逻辑**
- **统一入口**：所有 Token 的创建通过工厂类的方法完成。
- **减少重复**：避免在多个位置重复编写 `Token{...}` 的初始化代码。

#### **2. 增强可扩展性**
若需新增 Token 类型（例如支持函数调用）：
```cpp
// 扩展 TokenType
enum class TokenType { ..., Function };

// 扩展工厂类
class TokenFactory {
public:
    static Token createFunction(const string& name) {
        return { TokenType::Function, 0, 0, name }; // 假设扩展了 Token 结构体
    }
};
```

#### **3. 类型安全**
- 工厂方法明确参数类型，避免字段误用：
  ```cpp
  // 直接构造可能出错
  Token t{ TokenType::Operator, 3.14, 0 }; // value 字段误填了数值

  // 工厂方法强制约束
  Token t = TokenFactory::createOperator('+'); // 保证 op 字段有效
  ```

#### **4. 代码可读性**
- 方法名自解释：
  ```cpp
  TokenFactory::createLeftParen()  // 明确创建左括号
  vs
  Token{ TokenType::LeftParen, 0, 0 }
  ```

---

### **四、更复杂的工厂场景**
如果 Token 的创建需要依赖外部状态（如处理负号时的上下文），可升级为 **非静态工厂类**：

#### **1. 带状态的工厂类**
```cpp
class TokenFactory {
private:
    bool isNegative = false; // 跟踪负号状态

public:
    Token createNumber(double value) {
        if (isNegative) {
            value = -value;
            isNegative = false;
        }
        return { TokenType::Number, value, 0 };
    }

    void markNegative() { 
        isNegative = true; 
    }
};
```

#### **2. 在 Lexer 中使用**
```cpp
TokenFactory factory;

if (current == '-' && isNegativeContext()) {
    factory.markNegative();
} else {
    auto token = factory.createNumber(parsed_value);
    tokens.push_back(token);
}
```

---

### **五、总结**
虽然原代码未使用工厂模式，但通过引入 `TokenFactory` 类，可以实现以下改进：

| 改进点               | 说明                          |
|----------------------|-----------------------------|
| **代码集中化**       | 统一 Token 创建入口            |
| **扩展成本降低**     | 新增 Token 类型只需修改工厂类   |
| **错误率降低**       | 通过方法约束字段有效性          |
| **可读性提升**       | 方法名自描述创建意图            |

#### **适用场景建议**
- 当对象创建逻辑复杂或需要复用时可引入工厂模式。
- 若代码规模较小，直接构造可能更简洁；但复杂项目中使用工厂模式更有优势。
