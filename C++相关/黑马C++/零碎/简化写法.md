**自动类型推导**`auto`：
`vector<int>::iterator it == v.begin()`等于`auto it = v.begin()`

**基于范围的`for`循环**：简化容器的遍历过程
```cpp
for (declaration : expression) {
    // 循环体
}
//declaration：声明一个变量，用于在每次迭代中存储从`expression`中获取的元素。
//expression：一个容器或者任何可以提供`begin()`和`end()`迭代器的序列。
for (int num : vec) { std::cout << num << " "; }
for (int& num : vec) {}
```

**初始化成员列表**：
```cpp
class ClassName {
public:
    ClassName(Type1 a, Type2 b) : member1(a), member2(b) {
        // 构造函数体
    }

private:
    Type1 member1;
    Type2 member2;
};
```


## 结构体的聚合初始化:
这是一个 **C++ 结构体的聚合初始化语法**，在代码中用来初始化 `Token` 结构体的实例。让我们拆解它的组成部分：

---

### **1. 结构体定义回顾**
代码中定义的 `Token` 结构体：
```cpp
struct Token {
    TokenType type;  // 类型（枚举值）
    double value;     // 数值（当type=Number时有效）
    char op;          // 运算符字符（当type=Operator时有效）
};
```

---

### **2. 初始化语法解析**
`Token{Number, 3, 0}` 的含义：
- **`Number`**：对应 `TokenType::Number` 枚举值（代码中 `TokenType` 是 `enum class`，严格应为 `TokenType::Number`，可能是示例中的简写）
- **`3`**：数值部分（`value` 字段）
- **`0`**：运算符占位符（`op` 字段，因类型为 `Number` 时此字段无意义，用 `0` 填充）

---

### **3. 语法合法性说明**
这是合法的 **C++聚合初始化（Aggregate Initialization）**，满足以下条件：
1. **成员顺序匹配**：按结构体声明顺序初始化（`type → value → op`）
2. **类型隐式转换**：
   - `Number`（假设为 `TokenType::Number`）匹配 `TokenType` 枚举类型
   - `3` 隐式转换为 `double` 类型（`value` 字段）
   - `0` 隐式转换为 `char` 类型（`op` 字段）

---

### **4. 实际代码中的用法**
在词法分析器（`Lexer`）中，生成 `Token` 的代码为：
```cpp
// 生成数值类型的 Token
tokens.push_back({ TokenType::Number, parsed_value, 0 });

// 生成运算符类型的 Token
tokens.push_back({ TokenType::Operator, 0, current_char });
```
- **字段选择规则**：
  - 当 `type` 为 `Number` 时，仅 `value` 有效，`op` 填 `0`
  - 当 `type` 为 `Operator` 时，仅 `op` 有效，`value` 填 `0`

---

### **5. 对比其他初始化方式**
#### **方式 1：具名初始化（C++20 起支持）**
```cpp
Token t { 
    .type = TokenType::Number, 
    .value = 3, 
    .op = 0 
};
```
- 优点：明确字段名，避免顺序错误
- 缺点：需 C++20 或更高标准

#### **方式 2：构造函数初始化**
若为 `Token` 添加构造函数：
```cpp
struct Token {
    Token(TokenType t, double v, char o) 
        : type(t), value(v), op(o) {}
    // ...其他成员
};
```
则初始化方式为：
```cpp
Token t(TokenType::Number, 3, 0);
```

---

### **6. 你的代码中的注意事项**
- **枚举作用域**：原代码中 `TokenType` 是 `enum class`，严格应写 `TokenType::Number`，而非直接写 `Number`。
- **字段清理**：当 `type` 为 `Number` 时，`op` 字段的值实际不会被使用，但显式初始化为 `0` 是良好的编程习惯。

---

### **总结**
`Token{Number, 3, 0}` 是 C++ 结构体的聚合初始化语法，直接按成员顺序赋值。在计算器代码中，这种写法简洁高效，但需注意 **字段顺序** 和 **枚举作用域** 的细节。
