我们要总结 `synchronized` 的用法，核心只有一句话：**它是一把加在“对象”上的锁，用来保证同一时间只有一个线程能进入特定的代码区域。**

根据加锁的位置和锁的对象不同，可以分为以下三大类用法：

---

### 一、 对象实例锁（对象锁）
**锁的对象：** 当前的实例对象 `this`。
**影响范围：** 只有竞争**同一个对象实例**的线程才会排队。

#### 1. 同步实例方法
直接写在方法声明上。
```java
public synchronized void method() {
    // 逻辑代码
}
```

#### 2. 同步代码块（使用 `this`）
效果与上面完全一样，但粒度更细。
```java
public void method() {
    synchronized(this) {
        // 只有这里的逻辑是同步的
    }
}
```

---

### 二、 类全局锁（类锁）
**锁的对象：** 该类的 `Class` 对象（每个类在 JVM 只有一个）。
**影响范围：** **全系统唯一**。无论 `new` 多少个对象，全世界的线程都要在这里排队。

#### 1. 同步静态方法
```java
public static synchronized void method() {
    // 静态逻辑
}
```

#### 2. 同步代码块（使用 `.class`）
```java
public void method() {
    synchronized(MyClass.class) {
        // 全局唯一的同步区
    }
}
```

---

### 三、 指定对象锁（私有锁）
**锁的对象：** 程序员自己创建的任意对象。
**影响范围：** 只有拿到这个特定对象引用的线程才会排队。这是最推荐、最灵活的写法。

```java
public class MyService {
    // 推荐：私有的、不可变的锁对象
    private final Object lock = new Object();

    public void doWork() {
        synchronized(lock) {
            // 只有拿到 lock 这把钥匙的线程能进来
        }
    }
}
```

---

### 四、 `synchronized` 的三大特性（底层本质）

1.  **原子性（Atomicity）：** 保证代码块内的操作是不可分割的整体，不会被中途插队。
2.  **可见性（Visibility）：** 保证线程退出锁时，会将修改后的变量**立刻刷新回主内存**，让其他线程能看到。
3.  **可重入性（Reentrancy）：** 
    *   **本质：** 同一个线程拿到锁后，可以再次进入这个锁保护的其他代码块。
    *   **例子：** 方法 A 调方法 B，两个都有 `synchronized`，如果是同一个锁，线程可以直接进去，不会把自己锁在外面。

---

### 五、 避坑与最佳实践（高手建议）

1.  **粒度最小化：** 不要锁住整个方法，只锁住操作共享变量的那几行代码，提高并发效率。
2.  **避免用 String 做锁：** 因为 String 有常量池缓存，可能会导致两个完全不相关的业务逻辑因为共用了同一个字符串字面量而互相阻塞。
3.  **避免用包装类做锁：** 因为 `Integer`, `Long` 等有缓存（-128~127），容易产生和 String 类似的问题。
4.  **异常自动释放：** 这是一个巨大的优点。如果 `synchronized` 块内发生了异常，JVM 会**自动释放锁**，不会产生死锁（对比之下，`ReentrantLock` 必须在 `finally` 里手动释放）。
5.  **配合 `volatile`：** 如果只是为了可见性（比如一个开关位），用 `volatile` 性能远高于 `synchronized`。

### 总结口诀：

*   **同步方法锁 `this`，静态同步锁 `class`。**
*   **代码块里看括号，对象一致才排队。**
*   **粒度越小性能好，私有对象最可靠。**