notify()会随机唤醒一个线程，容易引发信号丢失；而notifyAll()会唤醒所有线程，绝大多数情况下应该使用notifyAll()

---

## 一、 核心概念：什么是等待/唤醒机制？
在多线程编程中，除了“竞争（抢锁）”，更多的时候需要“协作”。`wait()` 和 `notify()` 是 Java 提供的最底层的线程间通信机制，用于让线程在某个条件不满足时**主动让出 CPU 和锁**，并在条件满足时被**精准唤醒**。

### 1. 为什么定义在 Object 类中？
这是 Java 设计的高明之处：由于 Java 中**任何对象都可以作为锁**，而锁的信息（Monitor）存储在对象头中，因此操控锁状态的方法必须定义在 `Object` 类里，确保所有对象都具备这种能力。

---

## 二、 工作原理：监视器模型（Monitor）
理解这两个方法的关键在于 JVM 内部的两个**集合**：

1.  **Entry Set（锁池/入口集）：** 存放那些正在竞争锁、处于 `BLOCKED` 状态的线程。
2.  **Wait Set（等待池）：** 存放那些调用了 `wait()`、处于 `WAITING` 状态的线程。

### 动作拆解：
*   **`wait()`：** 线程执行此方法后，会立即释放持有的锁，并把自己从“诊室”挪到“**Wait Set**”里挂起。
*   **`notify()`：** 线程执行此方法后，会从“Wait Set”里随机唤醒一个线程，把它挪到“**Entry Set**”里重新排队抢锁。
    *   *注意：调用 `notify()` 后锁不会立即释放，必须等当前线程把 `synchronized` 块里的代码跑完。*

---

## 三、 黄金法则：使用规范与避坑

### 1. 必须在 `synchronized` 内部调用
如果没有锁就调用，会抛出 `IllegalMonitorStateException`。因为 `wait` 的本质是“释放锁”，如果你手里没锁，谈何释放？

### 2. 必须使用 `while` 而不是 `if`（防御性编程）
这是多线程中最经典的 Bug 来源。

```java
// ❌ 错误做法
if (条件不满足) {
    obj.wait();
}

// ✅ 正确做法
while (条件不满足) {
    obj.wait();
}
```
**原因：**
*   **虚假唤醒（Spurious Wakeup）：** 操作系统底层可能会在没有 `notify` 的情况下意外唤醒线程。
*   **二次竞争：** 线程被唤醒后到重新抢到锁之间有一个时间差，此时条件可能被其他线程抢先修改了。使用 `while` 可以确保抢到锁后**再次检查**条件。

---

## 四、 形象类比：医生看病模型
*   **诊室** = `synchronized` 代码块
*   **医生** = CPU 资源
*   **病人** = 线程
*   **化验单** = 协作条件

1.  **病人入诊**：线程 A 获取锁，进入 `synchronized`。
2.  **去化验吧**：发现条件不满足（没化验单），调用 `wait()`。病人**离开诊室（释放锁）**，去**化验等待区（Wait Set）**坐着。
3.  **下一位**：其他线程进入诊室。
4.  **化验完了**：线程 B 进诊室拿到了药，顺便喊一嗓子（`notify`）：“那个化验的可以回来了！”
5.  **重新排队**：病人 A 听到后，回到**诊室门口排队区（Entry Set）**，等里面的病人出来后重新抢位子。

---

## 五、 wait() vs Thread.sleep()

| 特性 | wait() | sleep() |
| :--- | :--- | :--- |
| **所属类** | `Object` | `Thread` |
| **锁状态** | **释放锁**，给别人机会 | **死抱住锁**，谁也别想进 |
| **用途** | 线程间通信/协作 | 简单的暂停执行 |
| **唤醒** | 需要 `notify` 或超时 | 时间到了自动醒 |

---

## 六、 实战模板：生产者-消费者（单容量）

```java
class Resource {
    private boolean flag = false; // 标志位：是否有产品

    public synchronized void produce() throws InterruptedException {
        while (flag) { // 如果有产品，生产者等待
            this.wait();
        }
        // 生产逻辑...
        flag = true;
        this.notifyAll(); // 生产完，唤醒消费者
    }

    public synchronized void consume() throws InterruptedException {
        while (!flag) { // 如果没产品，消费者等待
            this.wait();
        }
        // 消费逻辑...
        flag = false;
        this.notifyAll(); // 消费完，唤醒生产者
    }
}
```

---

## 七、 总结：什么时候用？
当你发现多个线程在处理同一个资源，且它们的执行顺序有**前置依赖关系**（如：没数据不能读、满了不能写）时，请立刻想到 `wait()` 和 `notify()`。

**一句话核心：** `wait()` 是为了**让出位置**，`notify()` 是为了**传递接力棒**。