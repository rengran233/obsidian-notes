---
tags:
  - Java
---
## 1. 语法现象：双括号初始化 (Double Brace Initialization)
在 Java 中，我们常看到这种极简主义的写法：
```java
List<String> list = new ArrayList<String>() {{
    add("A");
    add("B");
}};
```
表面上看，这只是在创建对象时顺便加了点数据。但在编译器眼中，这是一个**定义并实例化子类**的过程。

---

## 2. 深度拆解：每一个符号的含义

我们将 `new ArrayList<String>() { { ... } };` 拆分为四个部分：

1.  **`new ArrayList<String>`**：声明父类。你告诉编译器，这个新类要继承自 `ArrayList`。
2.  **`()`**：**父类构造函数调用**。
    *   **本质**：匿名子类没有名字，无法写自己的构造函数。它必须借用 `super()`（父类构造函数）来完成基础的内存分配和数据结构初始化。
    *   **作用**：它是子类诞生的“准考证”，没有它，子类无法开启生命周期。
3.  **第一层 `{ ... }`（外层）**：**匿名内部类的主体定义**。
    *   只要 `()` 后面跟了大括号，你就已经不再是在创建一个 `ArrayList` 对象，而是在**定义一个继承自它的子类**。
    *   编译器会为此生成一个新的 `.class` 文件（如 `Main$1.class`）。
4.  **第二层 `{ ... }`（内层）**：**实例初始化块 (Instance Initializer Block)**。
    *   **逻辑**：在 Java 中，初始化块会在构造函数执行时、`super()` 之后、子类构造代码之前运行。
    *   **必要性**：因为匿名类没有名字，无法写构造函数，所以**实例初始化块是匿名类执行复杂初始化逻辑的唯一场所**。

---

## 3. 核心机制：为什么调用父类构造函数，得到的却是子类？

这是 Java 继承体系的“改装车”逻辑：

*   **继承链条**：子类对象的创建必须以父类的构造为基础。
*   **编译器黑盒**：当你写 `new Parent() { ... }` 时，编译器悄悄做了三件事：
    1.  造一个新类：`class Anon extends Parent`。
    2.  给新类一个默认构造函数，内部只写一句话：`super()`。
    3.  把你在内层大括号写的代码，塞进这个 `Anon` 类的实例化流程中。
*   **结论**：调用父类构造函数只是**施工过程中的地基阶段**，最终盖出来的房子（对象实体）是由你最后的大括号决定的“定制款”。

---

## 4. 扩展知识：静态块 vs 实例块 vs 构造函数

| 类型 | 语法 | 归属 | 执行时机 | 核心用途 |
| :--- | :--- | :--- | :--- | :--- |
| **静态初始化块** | `static { ... }` | 类 (Class) | 类加载时 (仅一次) | 初始化类级别的静态资源 (如驱动、配置) |
| **实例初始化块** | `{ ... }` | 对象 (Object) | 每次 `new` 时 | 匿名类初始化、多个构造函数的公共代码提取 |
| **构造函数** | `Name() { ... }` | 对象 (Object) | 最终执行 | 根据传入参数进行特定初始化 |

---

## 5. 性能与陷阱 (Performance & Warnings)

虽然这种写法很“酷”，但在生产环境下需要警惕以下三点：

1.  **内存泄漏 (Memory Leak)**：
    *   **真相**：非静态匿名内部类会**隐式持有外部类对象的引用**（通过一个隐藏的 `this$0` 指针）。
    *   **后果**：如果这个 `list` 存活时间很长，它会拽着外部的大对象（如 Activity/Service）不放，导致内存无法回收。
2.  **性能损耗**：
    *   每一处这种写法都会生成一个独立的 `.class` 文件。大量使用会增加元空间（Metaspace）的压力。
3.  **序列化陷阱**：
    *   匿名类在进行 JSON 序列化（如使用 Jackson/Gson）时经常报错，因为它们没有标准的无参构造函数，且类名是动态生成的。

---

## 💡 总结一句话
**`()` 里的参数是传给父类初始化框架用的，而外层的 `{}` 是你宣告“我要创造一个新物种”的印章；匿名内部类就是通过“借用父类身份”来完成“自我个性化”的产物。**

