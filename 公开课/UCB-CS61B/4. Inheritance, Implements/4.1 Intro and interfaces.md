### 1.Intro to inheritance
```Java
// interface inheritance
// Deque.java
public interface Deque {
	public void addFirst();
}
// LinkedListDeque.java
public class LinkedListDeque implements Deque {
	@Override
	public void addFirst() {
		...
	}
}
```
- a concrete class must implement all **abstract methods** (i.e. excluding methods declared keyword `default`)
- `@Override` is a annotation to mark a overrided method
```Java
// implementation inheritance
public interface Deque {
	public int size();
	public void get(int index);
	default public void print() {
		for (int i = 0; i < size(); i += 1) {
			System.out.print(get(i) + " ");
		}
		System.out.println();
	}
}
// implement method in interface with known methods
```
`default` keyword can implement a method inside interface

### **2.dynamic selection(runtime polymorphism)**
1. **Compile-Time Check:** The compiler looks at the **reference type** (the variable's declared type) to ensure the method you are calling actually exists. This is a safety check.
2. **Run-Time Execution:** When the program runs, the Java Virtual Machine (JVM) looks at the **object's actual type** (the class it was created from) and executes the method belonging to that class.

### **3.Override vs. overlode**
```Java
// Animal.java
public interface Animal {
  default void greet(Animal a) {
    print("hello animal"); }
  default void sniff(Animal a) {
    print("sniff animal"); }
  default void flatter(Animal a) {
    print("u r cool animal"); }
}
// Dog.java
public class Dog implements Animal {
  void sniff(Animal a) {
    print("dog sniff animal"); }
  void flatter(Dog a) {
    print("u r cool dog"); }
}
// Main.java
Animal a = new Dog();  // compile-type is Animal and runtime-type is Dog
Dog d = new Dog();
a.greet(d);   // "hello animal"
a.sniff(d);   // "dog sniff animal"
d.flatter(d); // "u r cool dog"
a.flatter(d); // “u r cool animal”
```
`Dog.flatter()` is not overrided version of `Animal.flatter` but overloded, they have different signatures. Overloded methods were selected in compile-time.

1. **Overriding:** A subclass provides a specific implementation of a method that is already defined in its superclass or interface. **The method signature (name and parameter types) must be identical.** This is resolved at runtime.
    
2. **Overloading:** A class has multiple methods with the same name but **different parameter types**. This is resolved at compile time.
