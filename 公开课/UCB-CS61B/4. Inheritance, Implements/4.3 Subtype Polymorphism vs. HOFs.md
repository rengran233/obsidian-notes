### **1.maximizer and OurComparable**
```Java
// A wrong max method for example
public static Object max(Object[] items) {
    int maxDex = 0;
    for (int i = 0; i < items.length; i += 1) {
	    // Not every Object can use > to compare
        if (items[i] > items[maxDex]) {
            maxDex = i;
        }
    }
    return items[maxDex];
}

public static void main(String[] args) {
    Dog[] dogs = {new Dog("Elyse", 3), new Dog("Sture", 9), new Dog("Benjamin", 15)};
    Dog maxDog = (Dog) max(dogs);
    maxDog.bark();
}
```
If we want to write a universal method to compare some custom classes,  built-in comparison operators can't do it. We can override a operator in C++ or Python, but Java don't afford it. Instead of using **interface inheritance** 
```Java
// right practise in Java to implement max thod
// OurComparable.java
public interface OurComparable {
	// can deal with multiple types
	public int compareTo(Object o)
}
// Dog.java
public class Dog implements OurComparable {
    private String name;
    private int size;

    public Dog(String n, int s) {
        name = n;
        size = s;
    }

    public void bark() {
        System.out.println(name + " says: bark");
    }

    // Return negative number if this < o.
	// Return 0 if this equals o.
	// Return positive number if this > o.
	public int compareTo(Object o) {
		// cast Object type to Dog type for size variable
	    Dog uddaDog = (Dog) o;
	    return this.size - uddaDog.size;
	}
}
// Maximizer.java
public class Maximizer {
	public static OurComparable max(OurComparable[] items) {
	    int maxDex = 0;
	    for (int i = 0; i < items.length; i += 1) {
	        int cmp = items[i].compareTo(items[maxDex]);
	        if (cmp > 0) {
	            maxDex = i;
	        }
	    }
	    return items[maxDex];
	}
}
```

### **2.Java built-in Comparable and Comparator**
```Java
// Comparable
public interface Comparable<T> {
	public int compareTo(T obj);
}
// Dog.java
public class Dog implements Comparable<Dog> {
    ...
    public int compareTo(Dog uddaDog) {
        return this.size - uddaDog.size;
    }
}
```
Java has built-in `Comparable` class to work like `OurComparable` using **generic type** to avoid explicitly casting OurComparable type
```Java
// Comparator
import java.util.Comparator;

public class Dog implements Comparable<Dog> {
    ...
    public int compareTo(Dog uddaDog) {
        return this.size - uddaDog.size;
    }

    private static class NameComparator implements Comparator<Dog> {
        public int compare(Dog a, Dog b) {
            return a.name.compareTo(b.name);
        }
    }
	// instead of use new directly for convention
    public static Comparator<Dog> getNameComparator() {
        return new NameComparator();
    }
}
```
