### 5.1 Autoboxing
##### 5.1.1 Autoboxing of wrapper type
When we use generic in Java, we have to subsitute it with a concrete class (reference type) instead of a primitive type. To resolve this, we use reference types are corresponding to them called wrapper types.
But we don't want to do this everytime: 
```Java
public class BasicArrayList {
    public static void main(String[] args) {
      ArrayList<Integer> L = new ArrayList<Integer>();
      L.add(new Integer(5));
      L.add(new Integer(6));

      /* Use the Integer.valueOf method to convert to int */
      int first = L.get(0).valueOf();
    }
}
```
As we don't have to do it because Java will automatically box and unbox values between primitive types and its corresponding reference types.
**Caveat:** Autoboxing won't happen when you assigh a `Integer[]` array with a `int[]` array.
##### 5.1.2 Widen
```Java
public static void useInt(int a) {}  
  
public static void useDouble(double d) {}  
  
public static void main(String[] args) {  
    int aint = 10;  
    double adouble = 20;  
    useInt(adouble); // compile-time error
    useDouble(aint); // legal syntax
}
```
Java will automatically **widen a narrower type** to a wider type but must **cast a wider type** to a narrower type manully

### 5.2 Immutability

### 5.3 Generics
##### 5.3.1 Generic method
If we need to write a helper method to assist a genric class, we don't want to write type parameters behind class name. Because if we do so, we must create a instance of helper class to use the static method of it, which is not we want.
```Java
// We don't care what type of K or V is in a helper class,
// we just need the helper method to return a V object
public class MapHelper<K, V> {
	public static V get(Map61B<K,V> map, K key) {
		...
	}
}
```
We should write type parameters behind `static` keyword
```Java
// K and V are only valid in this scope
public static <K,V> V get(Map61B<K,V> map, K key) {
    if map.containsKey(key) {
        return map.get(key);
    }
    return null;
}
```
##### 5.3.2 Generic compare
When you want to compare generic types, both `>` and `compareTo()` are invalid
```Java
public static <K, V> K maxKey(Map61B<K, V> map) {
    List<K> keylist = map.keys();
    K largest = map.get(0);
    for (K k: keylist) {
	    // if (k > largest)
        if (k.compareTo(largest)) {
            largest = k;
        }
    }
    return largest;
}
```
To do this, we should use `extends`
```Java
// We must specific what kind of Comparable we want
// because Comparable is a generic interface
public static <K extends Comparable<K>, V> K maxKey(Map61B<K, V> map) {...}
```
In this case, we use `extends` instead of `implements` though `Comparable` is a interface because `extends` in generic context has a different meaning to inheritance context. This different use of `extends` called type upper bounding.