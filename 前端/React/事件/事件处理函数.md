React 的事件处理本质上是将**函数式编程**的理念注入到了 UI 交互中。

---

### 1. 语法差异：命名与传参
React 对原生 HTML 事件做了一层包装，在写法上有两个显著区别：

*   **命名**：使用 **小驼峰 (camelCase)**，而不是纯小写。
    *   HTML: `onclick`, `onchange`, `onsubmit`
    *   React: `onClick`, `onChange`, `onSubmit`
*   **赋值**：传递 **函数引用 (Function Reference)**，而不是字符串。
    *   HTML: `<button onclick="activateLasers()">`
    *   React: `<button onClick={activateLasers}>`

#### 💀 新手最容易犯的错：立即执行 vs 函数引用
这是有经验的开发者转 React 时最容易手滑的地方。

```jsx
// ❌ 错误：带了括号 ()
// 这会导致组件渲染时，handleClick 立即执行！
// 而不是等到点击时才执行。
<button onClick={handleClick()}>保存</button>

// ✅ 正确：只传函数名
// 意思是：“React，把这个函数存起来，等用户点的时候再调用它”
<button onClick={handleClick}>保存</button>
```

---

### 2. 参数传递 (Passing Arguments)
在后端开发中，调用函数传参是天经地义的。但在 React 的 `onClick` 里，因为你不能直接写括号 `()`，传参就变得有点技巧性。

假设你要实现：**“点击删除按钮，删除 ID 为 5 的用户”**。

#### ❌ 错误写法
```jsx
// 错！渲染时就会把 ID 为 5 的删了，因为函数立即执行了
<button onClick={handleDelete(5)}>删除</button>
```

#### ✅ 方案 A：箭头函数包裹 (Arrow Function Wrapper) —— **最常用**
创建一个匿名函数，在这个匿名函数体内调用真正的逻辑。
```jsx
// 原理：onClick 拿到的是这个匿名箭头函数。
// 当点击发生时，匿名函数执行，进而调用 handleDelete(5)。
<button onClick={() => handleDelete(5)}>删除</button>
```

#### ✅ 方案 B：柯里化 (Currying) —— **高阶函数思维**
如果你的 `handleDelete` 函数本身返回另一个函数。
```jsx
// 定义
const handleDelete = (id) => () => {
  console.log('删除', id);
};

// 使用 (这里写括号是对的，因为它返回的是一个函数)
<button onClick={handleDelete(5)}>删除</button>
```

---

### 3. 事件对象 `e` 的隐式传递
当你不传递自定义参数时，React 默认会将 **合成事件对象 (SyntheticEvent)** 作为第一个参数传给处理函数。

```jsx
// 定义
const handleClick = (e) => {
  // e 是 React 包装过的，不是原生的 DOM Event
  e.preventDefault(); // 阻止默认行为
  e.stopPropagation(); // 阻止冒泡
  console.log(e.target); // 获取点击的元素
};

// 使用
<button onClick={handleClick}>点击</button>
```

**如果你用了箭头函数传自定义参数，`e` 怎么拿？**
你需要显式地把它透传进去：

```jsx
//           显式接收 e      显式传递 e
<button onClick={(e) => handleDelete(id, e)}>删除</button>
```

---

### 4. 这里的 `this` 去哪了？
如果你在看老的 React 教程（类组件 Class Component），你会看到大量的 `.bind(this)`。

**在现代 React (Hooks / Function Component) 中：**
*   **没有 `this` 烦恼**。
*   组件本身就是一个闭包。你在组件内部定义的 `const handleClick = () => {}` 可以直接访问组件内的 `props` 和 `state`，完全不需要处理 `this` 上下文。

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  // 直接访问 count，不用 this.state.count
  const handleClick = () => {
    setCount(count + 1);
  };

  return <button onClick={handleClick}>+1</button>;
}
```

---

### 5. 性能优化：`useCallback`
在大型应用中，如果你像下面这样写：

```jsx
// 每次父组件渲染，都会重新创建一个新的匿名函数对象 () => ...
// 这会导致 ChildComponent 认为 props 变了，从而可能导致子组件无意义重渲染
<ChildComponent onClick={() => doSomething(id)} />
```

**优化方案：**
使用 `useCallback` 缓存函数引用（也就是缓存了内存地址）。

```jsx
const handleChildClick = useCallback(() => {
  doSomething(id);
}, [id]); // 只有 id 变了，函数地址才变

// 传给子组件的是稳定的引用
<ChildComponent onClick={handleChildClick} />
```

---

### 6. TypeScript 中的事件类型
既然你要写 TS，事件处理函数的类型定义是必修课。你不能总是写 `any`。

React 提供了标准的泛型接口。

*   **鼠标点击**：`React.MouseEvent<HTMLButtonElement>`
*   **输入框改变**：`React.ChangeEvent<HTMLInputElement>`
*   **表单提交**：`React.FormEvent<HTMLFormElement>`

**标准模板：**

```typescript
// TS 写法示例
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  // TS 知道 e.target 是 input 元素，所以会有 value 属性的提示
  console.log(e.target.value);
};

return <input onChange={handleChange} />;
```

### 总结 React 事件处理三定律

1.  **只传引用**：`onClick={func}`，不要加括号 `func()`（除非你用了柯里化）。
2.  **传参要包**：想传参数，就用箭头函数包一层 `onClick={() => func(id)}`。
3.  **阻止默认**：表单提交记得写 `e.preventDefault()`。