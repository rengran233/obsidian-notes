在软件开发（尤其是 Web 后端开发）中，**中间件 (Middleware)** 指的是**介于“请求（Request）”和“最终业务逻辑（Controller）”之间的一系列处理函数**。

你可以把它想象成工厂流水线上的一个个 **“加工站”** 或 **“安检员”**。当一个 HTTP 请求从浏览器发出来，到达你的 `AdController` 之前，它必须先经过这些关卡。

结合你的 **Mini Ad Wall** 项目（基于 Koa 框架），我为你拆解中间件的具体含义和作用。

### 1. 形象比喻：大楼的访客流程

假设你的 `AdController.createAd`（创建广告）是**公司 CEO**，而**用户请求**是一个**外来访客**。访客要见到 CEO，通常不能直接冲进办公室，而要经过以下流程：

1. **大门保安 (CORS 中间件):** “你是哪里来的？要是竞争对手公司（不允许的跨域源）来的，禁止入内！”
2. **前台接待 (BodyParser 中间件):** “你带了什么资料（JSON 数据）？我帮你整理成 CEO 能看懂的格式（JavaScript 对象）。”
3. **甚至更特殊的安检 (Multer 中间件):** “你带了包裹（文件上传）？我先检查一下有没有违禁品，然后帮你存到仓库，只给 CEO 一张提货单。”

只有通过了这三关，访客才能见到 CEO。**这三关，就是中间件。**

### 2. 你项目中的中间件实战

在你的代码中，中间件无处不在。请看 `server/src/app.ts` 和 `server/src/routes/adRoutes.ts`：

#### **A. 全局中间件 (Global Middleware)**

这些中间件就像大楼的总闸，**每个请求**都要经过它们。

* **`cors()` - 跨域门卫**
* **代码:** `app.use(cors());`
* **作用:** 它给响应头加上 `Access-Control-Allow-Origin`，允许前端（`localhost:5173`）访问后端。没有它，浏览器会拦截请求。


* **`bodyParser()` - 语言翻译官**
* **代码:** `app.use(bodyParser());`
* **作用:** 原生的 HTTP 请求体只是一串文本流。这个中间件帮你把这串流自动解析（Parse）成 JSON 对象，挂载到 `ctx.request.body` 上，方便你在 Controller 里直接读取 `body.title`。


* **`serve()` + `mount()` - 图书管理员**
* **代码:** `app.use(mount(..., serve(...)));`
* **作用:** 拦截特定路径（如 `/uploads`）的请求。如果发现用户想要的是个文件，它就直接去硬盘读取文件返回，**不再**让请求往后走去找 Controller 了（直接截胡）。



#### **B. 路由级中间件 (Route-Level Middleware)**

这些中间件只针对**特定路径**生效。

* **`multer` - 搬运工**
* **代码:** `router.post('/upload', upload.single('file'), AdController.uploadFile);`
* **作用:** 注意中间那个 `upload.single('file')`。
* 当请求到达 `/upload` 时，先由 `multer` 处理。它负责接收二进制文件流，保存到 `temp_uploads` 目录，然后把文件信息挂在 `ctx.file` 上。
* 只有文件上传成功了，它才会调用 `next()`，把控制权交给最后的 `AdController.uploadFile`。





### 3. Koa 的核心：洋葱模型 (Onion Model)

在答辩中，提到**“洋葱模型”**是解释 Koa 中间件的加分项。

* **原理:** 请求像穿过洋葱一样，一层层**向内**进入，直到中心（Controller），处理完后再一层层**向外**出来。
* **能力:** 中间件不仅可以在**请求前**做事（比如解析 Body），还可以在**响应后**做事（比如计算耗时）。

### 4. 为什么需要中间件？（架构思考）

如果不使用中间件，你需要在每个 Controller 函数里写重复的代码：

* **不好的写法 (无中间件):**
```typescript
// AdController.ts
async createAd(ctx) {
  // 1. 手动处理跨域
  ctx.set('Access-Control-Allow-Origin', '*');
  // 2. 手动解析 JSON流
  const data = await parseStream(ctx.req); 
  // 3. 终于开始业务逻辑...
}

```


* **好的写法 (有中间件):**
Controller 只关注业务：“给我数据，我存数据库。”
中间件负责脏活累活：“我负责解析数据、处理安全、记录日志。”

### 总结

**中间件 = 拦截器 + 处理器。**
它是实现**关注点分离 (SoC)** 的重要手段，让你的业务逻辑代码（Controller）保持纯净和专注。