这是一份为您定制的 **10分钟演讲稿**，字数控制在 **2000字左右**（中速演讲约9-10分钟）。

稿件中特别强化了“**为什么这么做**（架构思考）”和“**解决了什么问题**（工程挑战）”，这在面试或答辩中是最高分的点。

---

### **开场白 (建议 1 分钟)**

各位评委/老师好，我是 [你的姓名]。***自我介绍***
今天我将从架构设计、核心技术攻关以及工程化反思和优化三个维度来汇报我的迷你广告墙项目。

[切换PPT]
迷你广告墙不仅实现了基础的增删查改功能，还在此之上实现了三个进阶任务要求的前后端分离、动态表单和视频上传功能

---

### **第一部分：项目概览与架构演进 (建议 2 分钟)**

**[切换 PPT：项目简介与技术选型]**
在架构模式上，前端采用了MVVM，使用antd绘制组件UI，react query管理从后端请求的数据，自定义Hooks作为连接两者的桥梁；后端采用了MVC，整体上。
在技术选型上，我选择了 **React + TypeScript + Vite** 构建前端，后端则使用了 **Koa**

**[切换 PPT：状态管理架构演进]**
在架构设计上，前后端都有一些变动。
前端上，在没有引入后端时，最初我使用 **Zustand** 管理本地数据，并将数据直接存在浏览器的localStorage中。但随着前后端的分离，我意识到前端不应过度保留业务数据。
于是，我转为使用 **React Query** 来管理服务端状态。*这样做的优势在于：我不再需要手动维护大量的 `loading` 和 `error` 状态，而是通过 React Query 的缓存机制实现了服务端状态的同步。* 
同时，我严格遵循了 **View + Hook** 的分离模式，通过 **Barrel Pattern (index 文件统一导出)** 保持了组件结构的简洁。
后端上，最初我打算用类似于LowDB的方案直接把数据存储在本地文件，这样对于目前的测试小项目已经够用了，但是出于锻炼的目的，我选择使用了**Prisma ORM + SQLite 数据库**的方案。SQLite也提供了直接在本地文件存储数据的轻量化能力，而Prisma提供了强类型的 ORM 支持，在开发时可以免于SQL的字符串拼接，使用封装程度更高的对象方法。可以通过 Schema 定义模型并自动生成 TS 类型，能彻底消除数据库字段与代码不一致的隐患。

---

### **第二部分：进阶任务深挖 1——动态表单 (建议 2 分钟)**

**[切换 PPT：动态表单设计]**
对于这个任务，我去了解了动态表单的价值
在表单实现上，原本的表单是在前端硬编码的，每次修改标签或增加校验都需要重新发布代码。而如果使用由后端驱动的动态表单，可以免于频繁修改表单带来的前端发布麻烦

为了解决这个痛点，我设计并实现了**后端驱动的动态表单**：
1.  **Schema 定义：** 由后端返回一份 JSON 数据，描述每个字段的类型、标签、校验规则（Rules）以及对应的 Ant Design 组件。
2.  **动态映射：** 前端 `AdModal` 不再写死表单组件，而是遍历 Schema 数组，通过映射表动态渲染。

*对JSON数据的解析由axios自动完成，但是这是因为目前的JSON数据都是可以被直接解析的简单类型，如果涉及到复杂内容比如正则表达式，需要另外的解析函数*

*在开发模式下无用*

---

### **第三部分：进阶任务深挖 2——视频流与智能管理 (建议 2.5 分钟)**

**[切换 PPT：视频上传全链路]**
视频处理是本项目最核心的挑战。视频文件作为二进制流，无法直接存入数据库，必须处理好“文件-URL-记录”的关联。

本项目中视频资源上传和表单记录写入数据库是两个分开的动作。

视频资源的上传和请求可以分为三个部分：
1.  **物理落盘：** 后端通过 `Multer` 拦截流，使用 UUID 重命名防止冲突，存入物理路径。随后返回一个包含UUID名称的URL作为表单的一部分写入数据库
2.  **静态映射：** 利用 `koa-static` 暴露资源路径，将物理文件转化为可访问的 HTTP URL。
3.  **多视频支持：** 为了支持一则广告关联多个视频，我利用 Service 层对数据进行了序列化处理，在前端实现了 `fileList` 的动态映射。

**[切换 PPT：垃圾文件处理与引用计数]**
在基础的视频上传和请求功能完成后，我还遇到了一些问题。
首先是如果多则广告共用了同一个视频源，删除其中一则广告是否应该删除视频文件？如果广告是通过复制产生的，会和本体使用同样的视频URL
为了防止误删，我引入了 **引用计数（Reference Counting）** 机制。在删除逻辑中，系统会先统计当前视频被引用的次数。只有当计数小于等于 1 时，才会真正执行 `fs.unlink` 进行物理删除。

同时，针对用户上传了视频但没提交表单或者上传后删除选择了其他视频文件产生的**垃圾文件**，我设计了“临时目录-正式目录”迁移策略。文件首选进入临时区，只有表单成功提交后才转正，并配合定时任务清理临时区，确保了服务器存储空间的健康。

---

### **第四部分：交互优化与技术打板 (建议 1.5 分钟)**

**[切换 PPT：浏览器拦截与 UX 闭环]**
在开发视频播放功能时，我发现如果按照原有的要求，在视频播放结束后再使用 `window.open` 跳转，由于中间经历了异步等待，会被浏览器安全机制判定为“非用户主动行为”而拦截。*这样为什么不好？*

**我的解决方案是引入“结算层”：**
当视频播放结束，不再直接跳转，而是弹出一个半透明遮罩（结算层），提供“重播”和“立即查看”两个按钮。这不仅完美规避了浏览器拦截问题，更在 UX 上给予了用户反馈感，符合广告行业的转化逻辑。

**[切换 PPT：类型安全与代码规范]**
“在项目开发的中后期，随着功能增加，我发现单个组件文件变得越来越臃肿。为了提升工程质量，我进行了一次深度的架构打磨。

我引入了 **View-Hook 模式**：将原有的组件拆分为纯 UI 渲染的 Component.tsx 和专门负责逻辑处理的 useComponent.ts。

**这样做有两个核心价值：**  
第一，**职责单一化**。UI 层只关心‘长什么样’，逻辑层只关心‘数据怎么变’，这让代码结构一目了然。  
第二，**逻辑可复用**。封装在 Hook 里的逻辑不再依赖于特定的 UI 框架或 DOM 结构，如果未来我们需要开发移动端或另一个相似功能的页面，这些逻辑代码可以直接拿来复用，大大提升了工程的扩展性。”

*此外，我也在底层进行了不少打磨。例如在 TypeScript 中，Koa 默认不识别 `request.body`。我没有粗暴地使用 `any`，而是通过 **Module Augmentation（模块扩展）** 给 Koa 的 Request 接口声明了更准确的类型，确保了整个项目的编译时安全。*

---

### **结尾：未来规划与致谢 (建议 1 分钟)**

**[切换 PPT：总结与展望]**
“关于未来的方向规划，我目前的想法是采用**‘学术深耕’与‘工业实践’双线并行**的模式。

**首先，作为一名学生，我深知学校里的理论基础是决定职业天花板的关键。** 接下来我会继续在学校深入钻研计算机底层的核心知识，因为这次训练营让我意识到，无论是 Zustand 的状态流转还是 React Query 的缓存策略，底层都离不开对数据结构和网络协议的深刻理解。

**同时，我也非常渴望尽早接触真实的生产环境。** 训练营的经历让我体会到了‘解决真实问题’的快感。因此，我计划在保持学业优秀的潜提下，通过高质量的实习来了解真实的业务场景、团队协作和工程化规范。

我不希望只是闭门造车，我希望**在学校里练好‘内功’，在实习中磨炼‘招式’**，最终在毕业时能够无缝衔接，成为一名具备极强实战能力的前端工程师。”

---

### **演讲技巧小贴士：**
1.  **重音强调：** 讲到“引用计数”、“动态表单”、“重构为 React Query”这些关键词时，语速稍微放慢，加重语气。
2.  **眼神交流：** 不要盯着 PPT 读，PPT 只是辅助。你在讲“思考过程”时要看着听众。
3.  **PPT 配合：** 讲到第三部分视频处理时，PPT 上一定要有一张流程图，方便听众理解那一连串的后端动作。
4.  **备用 Q&A：** 如果被问到“为什么不选 Vue”，可以说 Vite+React+TS 是目前大厂工程化最成熟的组合之一，你更看重其生态和类型推导的严谨性。