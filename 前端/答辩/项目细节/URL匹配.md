这是一场非常精彩的**“谁来接单”**的博弈游戏。

虽然它们长得都很像（都是 `/a/b/c` 这种字符串），但系统区分它们的核心机制在于：**上下文环境（Context）** 和 **处理流水线的优先级（Pipeline Priority）**。

我们可以把这个过程想象成一个**层层过筛子**的过程。

---

### 1. 第一层区分：上下文协议 (Context & Protocol)

这是最外层的区分，决定了由**谁**来开始处理这个字符串。

* **场景 A：你在文件资源管理器里输入地址**
* **特征：** 盘符开头 (`C:\`) 或根目录开头 (`/usr/`).
* **区分者：** 操作系统内核。
* **结果：** 直接进行磁盘 I/O 寻址。


* **场景 B：你在浏览器地址栏输入地址**
* **特征：** 协议头开头 (`http://`, `https://`, `file://`).
* **区分者：** 浏览器。
* **结果：**
* 如果是 `file://`：浏览器调用操作系统打开本地文件（类似场景 A）。
* 如果是 `http://`：浏览器将其封装成 TCP 数据包，发给服务器。**接下来的区分压力给到了服务器。**





---

### 2. 第二层区分：服务器内部的“分拣流水线” (The Middleware Pipeline)

这是你项目中最关键的部分。当一个 HTTP 请求到达你的 Koa 后端（比如端口 3000）时，它是一个纯粹的字符串。Koa 是通过**中间件的注册顺序**和**特定前缀**来区分的。

让我们看看你的 Koa 代码（逻辑上的样子）是如何像**漏斗**一样工作的：

#### **第一关：特定前缀匹配 (Mounting)**

在你的 `app.ts` 中，你使用了 `koa-mount`。这是最高优先级的区分。

```typescript
// 规则：只要 URL 是以 /uploads 开头的，就强制由这个中间件接管
app.use(mount('/uploads', serve(...))); 

```

* **逻辑：**
1. 请求进来：`/uploads/video.mp4`
2. Koa 检查：开头是 `/uploads` 吗？
3. **是！** -> 进入 `serve` 静态服务逻辑 -> 去硬盘找文件 -> **请求结束，直接返回**。
4. **注意：** 此时请求根本不会走到后面的 Router 逻辑里去。



#### **第二关：路由正则匹配 (Router Matching)**

如果请求**没有**被第一关截获（比如 URL 是 `/ads/123`），它会漏到下一层。

```typescript
// 规则：剩下的请求，由路由器来尝试认领
app.use(router.routes());

```

* **逻辑：**
1. 请求进来：`/ads/123`
2. Koa 检查：是 `/uploads` 开头吗？**不是**。
3. 漏到 Router 中间件。
4. Router 拿出路由表（正则列表）开始比对：
* 匹配 `/^ads$/`？ -> No
* 匹配 `/^ads\/(\d+)$/`？ -> **Yes!**


5. **命中！** -> 执行对应的 Controller 函数 (`getAdById`) -> **请求结束，返回 JSON**。



#### **第三关：兜底逻辑 (404 Fallback)**

如果请求既不是 `/uploads` 开头，路由表里也找不到。

* **逻辑：**
1. 请求进来：`/nothing/here`
2. 静态服务？No。
3. 路由匹配？No。
4. **结果：** 没有任何人“举手”接单。Koa 默认返回 **404 Not Found**。



---

### 3. 辅助区分手段：URL 语义特征

除了上述的硬性代码逻辑，在实际开发中，我们通常会遵循一些**命名约定**，让人和机器更容易区分（虽然不是强制的）：

| 特征 | 暗示用途 | 对应处理者 | 例子 |
| --- | --- | --- | --- |
| **带扩展名** | 静态资源 | Static Middleware | `/logo.png`, `/style.css` |
| **带 `/api/` 前缀** | 数据接口 | API Router | `/api/users/1` |
| **纯单词路径** | 页面路由 | Frontend Router (React) | `/dashboard`, `/login` |

### 4. 总结：它们是如何“互不打架”的？

在你的 **Mini Ad Wall** 项目中，区分机制非常明确：

1. **看“前缀”：**
如果是 `/uploads`，服务器**断定**这是在找文件（静态资源），直接去硬盘读。
2. **看“动词”和“路径”：**
如果是 `/ads` 且是 `GET/POST`，服务器**断定**这是业务指令，交给 Controller 代码跑逻辑。
3. **看“运气”：**
如果都不是，那就是 404。

**一句话总结：**
区分不是靠 URL 字符串本身（因为它们长得一样），而是靠**服务器代码中中间件的“排队顺序”** —— 谁排在前面，谁就有权先检查并拦截这个 URL。