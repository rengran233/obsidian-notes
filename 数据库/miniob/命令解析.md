INSERT
insert_stmt:
获取表
使用`CharType::cast_to()`将指令中的字符串转化为数据值储存

CREATE TABLE
```
┌─────────────────────────────────────────────────────────────┐
│                   Table::create() 执行流程                    │
└─────────────────────────────────────────────────────────────┘

1. 参数校验
   ├─ 检查 table_id >= 0
   ├─ 检查表名非空
   └─ 检查字段列表非空
          ↓
2. 创建元数据文件 (.meta)
   ├─ open(...O_EXCL...)  // 原子性地创建文件
   └─ close(fd)           // 关闭文件描述符
          ↓
3. 初始化表元数据
   ├─ 获取事务字段 (trx_id, delete_flag)
   ├─ 解析用户字段 (id, name, age)
   └─ 创建 TableMeta 对象
          ↓
4. 序列化元数据
   ├─ 打开文件流
   ├─ table_meta_.serialize(fs)  // 写入二进制数据
   └─ 关闭文件流
          ↓
5. 创建数据文件 (.data)
   ├─ 构造文件路径
   ├─ bpm.create_file()
   │   ├─ 创建文件
   │   ├─ 初始化文件头
   │   └─ 创建 BufferPool
   └─ 设置 db_ 指针
          ↓
6. 创建存储引擎
   ├─ 根据 storage_engine 选择引擎
   │   ├─ HEAP  → HeapTableEngine
   │   └─ LSM   → LsmTableEngine
   ├─ engine_->open()
   │   ├─ 打开 BufferPool
   │   ├─ 读取文件头
   │   └─ 初始化记录管理器
   └─ 返回 SUCCESS
          ↓
✅ 表创建成功
```
储存引擎：关键部分，管理数据和磁盘交互

索引：父类没有close函数，但是B+树索引有
BplusTreeIndex->BplusTreeHandler->DiskBufferPool
DB::drop_table()->Table::drop()


date
词法、语法解析
common/data_type枚举定义和接口实现
Value

SELECT
直接调用数据类型中的`to_string()`函数，不涉及`cast_to()`函数
SELECT没有同名算子，而是使用其他三个算子
物理算子只负责返回原始的二进制数据（`Chunk`, `Tuple`）
数据转化为可视的字符串的过程发生在`net`部分

Table::make_record()
Value::to_string()
CharType::to_string()


yacc_sql.y:
%token: 可以解析的token
%union: 联合体，将token存储在其中
%type <sql_node>
command_wrapper: 包装命令，语法匹配