
sql_task_handler
command_executor
Table: records


好的，这是一个非常经典且循序渐进的数据库功能开发任务。我们来对这个需求进行一次彻底的、庖丁解牛式的分析，明确你要做什么、怎么做、以及需要注意的关键点。

---

### 1. 需求核心目标解析

**“实现更新行数据的功能”**

这句话是最终目的。具体来说，就是当用户输入一条 `UPDATE` SQL 语句后，数据库底层的物理存储文件中的对应数据行真的被修改了。

---

### 2. 约束与提示分析

*   **“当前实现 update 单个字段即可”**
    *   **含义**: 这是对你工作的极大简化。你不必费心去实现 `UPDATE t SET id=1, name='x'` 这样的多列更新。你的代码只需要处理 `SET` 后面只有一个 `列=值` 的情况。
    *   **对你的影响**: SQL 解析部分（Yacc/Bison）已经帮你做好了（虽然不完善），你可以暂时不用碰。你的核心工作在**执行层**和**存储层**。

*   **“现在 MiniOB 具有 insert 和 delete 功能，在此基础上实现更新功能。可以参考 insert_record 和 delete_record 的实现”**
    *   **含义**: 这是一个**至关重要的提示**。它告诉你，`UPDATE` 操作在底层实现上，并不是一个全新的原子操作，而是可以**复用** `DELETE` 和 `INSERT` 的逻辑。
    *   **核心思想**: 逻辑上，`UPDATE a row`  等价于 `DELETE the old row` + `INSERT the new row`。
    *   **对你的影响**: 你的主要工作不是从零写代码，而是**理解 `delete_record` 和 `insert_record` 的代码逻辑**，然后巧妙地将它们组合起来。你需要找到这两个函数，仔细阅读它们是如何操作数据页、槽位、记录头以及索引的。

*   **“目前仅能支持单字段update的语法解析，但是不能执行”**
    *   **含义**: 这明确了你的工作范围。SQL 解析器已经能把 `UPDATE` 语句翻译成一个 `ParsedSqlNode` (AST)。但是，从这个 AST 节点开始，到数据被真正修改的整个“执行”链路是断开的。你要做的就是**搭建这条执行链路**。

*   **“需要考虑带条件查询的更新，和不带条件的更新”**
    *   **含义**:
        *   **带条件 (`WHERE age = 1`)**: 你需要先**找出所有满足 `WHERE` 条件的行**。这通常意味着你需要实现一个“选择”或“扫描”的过程。
        *   **不带条件 (无 `WHERE` 子句)**: 你需要**找出表中的所有行**。这对应着一个“全表扫描”。
    *   **对你的影响**: 你的代码必须有一个“查找匹配行”的阶段。你需要复用或实现一个能够根据条件筛选记录的迭代器或函数。

*   **“同时需要考虑带索引时的更新”**
    *   **含义**: 这是任务的**难点和核心**。当更新一个被索引的字段时，不仅要修改表数据本身，还**必须同步修改对应的索引数据**，否则索引就会失效（数据和索引不一致）。
    *   **具体场景分析**:
        *   **Case 1: 更新的字段*不是*索引键 (e.g., `UPDATE t SET name = 'x' WHERE id = 1;`，假设索引在 `id` 上)**。
            *   你只需要更新主表数据。索引不需要动，因为 `id` 没变。
        *   **Case 2: 更新的字段*是*索引键 (e.g., `UPDATE t SET id = 10 WHERE id = 1;`)**。
            *   这是最复杂的情况。你必须：
                1.  从旧索引键 (`id=1`) 对应的索引项中，删除这条记录的指针。
                2.  在主表中更新数据行 (`id` 变为 `10`)。
                3.  向新索引键 (`id=10`) 对应的索引项中，插入这条记录的新指针。
            *   这又一次印证了 `UPDATE = DELETE + INSERT` 的思想：索引的更新也等价于一次索引的删除和一次索引的插入。

---

### 3. 你需要实现的具体东西 (代码实现路线图)

根据以上分析，你的工作可以分解为以下几个清晰的步骤：

#### **第一步：打通执行入口 (Executor)**

1.  **找到 SQL 执行的派发中心**: 在 MiniOB 的代码中，肯定有一个地方会根据 `ParsedSqlNode` 的类型 (e.g., `SCF_INSERT`, `SCF_SELECT`) 来决定调用哪个处理函数或创建哪个执行器 (Executor)。
2.  **添加 `UPDATE` 的处理分支**: 在这个派发中心，添加一个新的 `case SCF_UPDATE:`。
3.  **创建 `UpdateExecutor`**: 在这个 `case` 里，你需要创建一个新的执行器类，比如 `UpdateExecutor`，并把解析好的 `ParsedSqlNode` (包含了表名、要更新的列和值、WHERE 条件) 传递给它。

#### **第二步：实现查找匹配行的逻辑 (Scanner/Iterator)**

1.  在 `UpdateExecutor` 的 `execute()` 或 `open()` 方法中，你需要做的第一件事就是找到所有待更新的行。
2.  **创建扫描器**: 你需要创建一个**表扫描器 (Table Scanner)** 或者**索引扫描器 (Index Scanner)**。
    *   如果 `WHERE` 条件中的列有索引，并且优化器决定使用索引（在初赛阶段可能不需要考虑优化器，你可以自己判断），就使用索引扫描器，这样会快很多。
    *   否则，就使用全表扫描器。
3.  **应用 `WHERE` 条件**: 扫描器在遍历每一行时，你需要应用 `WHERE` 子句中的条件进行过滤，只保留满足条件的行。你需要一个评估表达式真假的模块。
4.  **收集结果**: 将所有满足条件的行的**唯一标识符 (RowID)** 收集起来，存入一个列表或 vector。为什么是 RowID？因为在你进行更新操作时，原始数据可能会移动，用 RowID 定位是最稳妥的。

#### **第三步：实现核心更新逻辑 (Update a Single Row)**

这是任务的核心，可以封装成一个独立的函数 `update_record(RowID, new_column_name, new_value)`。

1.  **循环处理**: 遍历上一步收集到的 RowID 列表。对于每一个 RowID，执行以下操作：
2.  **读取旧记录**: 根据 RowID，从数据页中读取出完整的旧记录。
3.  **构造新记录**:
    *   复制一份旧记录。
    *   修改这份副本中需要更新的那个字段的值。
4.  **处理索引 (关键！)**:
    *   遍历表的所有索引。
    *   对于每一个索引，检查被更新的字段**是否是该索引的一部分**。
    *   **如果是**:
        *   从旧记录中提取**旧的索引键**。
        *   调用**索引的删除接口** (`index->delete_entry(旧索引键, RowID)`)。
        *   从新记录中提取**新的索引键**。
        *   调用**索引的插入接口** (`index->insert_entry(新索引键, RowID)`)。
5.  **处理主表数据 (复用 Delete + Insert)**:
    *   调用底层的 `delete_record(RowID)`。这会处理数据页的槽位、释放空间等。
    *   调用底层的 `insert_record(新记录)`。这会为新记录找到存放位置，并返回一个新的 RowID (虽然在某些实现中可以做到原地更新，但 Delete+Insert 更简单且通用)。
    *   **注意**: 如果 `insert_record` 导致 RowID 变化，你需要确保索引中插入的是**新的 RowID**。

#### **第四步：返回结果**

`UPDATE` 命令通常会返回一个“受影响的行数”。你只需要在 `UpdateExecutor` 中记录下你成功更新了多少行（即 RowID 列表的大小），并在执行结束时返回这个数字即可。

---

### 总结：你的任务清单

1.  **[Executor层]** 创建 `UpdateExecutor` 类，并在 SQL 派发处调用它。
2.  **[Scanner层]** 在 `UpdateExecutor` 中，实现或复用一个扫描模块，该模块能根据 `WHERE` 条件筛选出所有匹配行的 RowID。
3.  **[Execution/Storage层]** 实现核心的单行更新逻辑：
    *   读取旧行。
    *   构造新行。
    *   **[索引维护]** 调用索引接口，完成“删旧插新”。
    *   **[表数据维护]** 调用 `delete_record` 和 `insert_record`，完成“删旧插新”。
4.  **[返回结果]** 统计并返回受影响的行数。

**给你的建议：**
**不要马上开始写 `UpdateExecutor`**。先去把 `delete_record` 和 `insert_record` (以及它们对索引的操作) 的代码**彻底读懂**。把这两个函数当成黑盒子，理解它们的输入和输出。一旦你理解了这两个“乐高积木”，搭建 `UPDATE` 这个“新模型”就会变得清晰很多。

### 1. **语句层 (Stmt)**

- 📄 `sql/parser/yacc_sql.y` - 添加 UPDATE 的语法规则
- 📄 `sql/stmt/update_stmt.h` - 定义 UpdateStmt 类
- 📄 `sql/stmt/update_stmt.cpp` - 实现语句解析逻辑

### 2. **逻辑算子层 (Logical Operator)**

- 📄 `sql/operator/update_logical_operator.h` - 定义逻辑算子
- 📄 `sql/operator/update_logical_operator.cpp` - 实现逻辑算子

### 3. **物理算子层 (Physical Operator)**

- 📄 `sql/operator/update_physical_operator.h` - 定义物理算子
- 📄 `sql/operator/update_physical_operator.cpp` - 实现执行逻辑

### 4. **优化器层**

- 📄 `sql/optimizer/logical_plan_generator.cpp` - 添加 UPDATE 的逻辑计划生成
- 📄 `sql/optimizer/physical_plan_generator.cpp` - 添加 UPDATE 的物理计划生成

### 5. **底层存储层**

- 📄 `storage/table/table.h` - 添加 `update_record()` 方法声明
- 📄 `storage/table/table.cpp` - 实现 `update_record()` 方法