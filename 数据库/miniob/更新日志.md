- `DROP TABLE`在删除带索引的表时出现错误，导致数据库尝试寻找不存在的`buffer pool`（？）
解决：删除`dblwr`文件
原因：Double Write Buffer`dblwr`记录了不需要的操作
- `Table::drop()`在执行删除索引时报错
原因：`indexes_`数组越界访问，元数据（记录仍有索引）和内存实例信息不同
解决：将索引对象和索引文件用`indexes_.size()`和`index_meta_num`分别删除
- 新增代码以实现`date`类型
往年代码很好用
- 创建`date_table`时元数据文件损坏，服务器崩溃
	- 在记录元数据到文件时出错`table_meta_.serialize(fs);`
原因：没有在`attr_type.cpp/attr_type_to_string()`中的数组中建立让类型名从枚举量到字符串的映射（.json文件生成出错）
解决：将`"dates"`加入数组即可
- 执行`INSERT INTO date_table VALUES (1,'2020-01-21');`失败
原因：将字符串日期改为整型日期的`cast_to()`没有实现
修改：`cast_to()`
原因2：创建表时在`ATTR_TYPE_NAME[]`数组中类型顺序错误，导致表中存储了错误的类型信息，以至于在将指令字符串转换为类型值时一直出错
注意：数据类型系统运行依赖枚举值，需要保证各处在定义各类型的顺序统一
- 在INSERT并存储日期数据时出错
原因：仅是因为指令转数据和数据转输出的逻辑不同，警惕AI代码
修改：重写`DateType::to_string()`
- `Value::init_value_`值一直为0
原因：忘了给`Value::set_data()`增加`DATES`分支，导致无法识别
注意：常看日志
- `SELECT`的`WHERE`子句不能正确执行
原因：没有规定`DATES`如何转为`CHARS`，逻辑算子不能比较
解决：在`DataType::cast_cost()`中规定
- `lex.l`文件中注释不能与语句在同一行
- 条件`<>`不等于执行错误
原因：索引导致了错误
原因2：优化时对于`<>`和`=`选择了使用索引导致错误
试验：`physical_plan_generator.cpp/create_plan(TableLogical)`，改了优化方案
- `UpdateStmt`的职责是是携带信息，而不是修改信息，其`value_`, `field_meta_`等成员都应该是`const`类型
- `update_record_with_trx()`