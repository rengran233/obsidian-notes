哈希冲突
- 链地址法
- 开放寻址
	- 线性探测
	- 平方探测
	- 多次哈希

查询时间复杂度O(1)
负载因子：元素数 / 桶数
哈希表不适合范围查询


### **1. 链地址法（Separate Chaining）**
- **原理**：每个哈希桶（bucket）维护一个链表（或红黑树），所有哈希到同一位置的元素都存储在该链表中。  
- **操作**：  
  - **插入**：将元素添加到对应桶的链表中。  
  - **查找**：遍历链表查找目标元素。  
- **优点**：实现简单，负载因子容忍度高。  
- **缺点**：链表过长时查找效率下降（可优化为树结构）。  
- **应用**：Java的 `HashMap`、C++的 `std::unordered_map`。

---

### **2. 开放寻址法（Open Addressing）**
- **原理**：所有元素直接存储在哈希表数组中，冲突时按探测策略（如线性探测、二次探测）寻找下一个空桶。  
- **探测方法**：  
  - **线性探测**：依次检查下一个位置（`hash(key) + i`）。  
  - **二次探测**：按平方跳跃（`hash(key) + i²`）。  
  - **双重哈希**：使用第二个哈希函数计算步长。  
- **优点**：无需额外内存存储指针，缓存友好。  
- **缺点**：负载因子需较低（通常 <0.7），否则性能急剧下降。  
- **应用**：Python的字典、Redis的哈希表。

---

### **3. 再哈希法（Double Hashing）**
- **原理**：当冲突发生时，使用第二个哈希函数计算新的位置。  
- **公式**：`new_hash = (hash1(key) + i * hash2(key)) % size`  
- **优点**：减少聚集现象（大量元素集中在某区域）。  
- **缺点**：需要设计良好的第二个哈希函数。

---

### **4. 公共溢出区法（Overflow Area）**
- **原理**：将哈希表分为主表和溢出区，冲突元素存入溢出区。  
- **操作**：主表桶满后，将元素插入独立的溢出链表或区域。  
- **优点**：主表结构简单。  
- **缺点**：溢出区可能成为性能瓶颈。  
- **应用**：早期数据库索引。

---

### **5. 完全哈希（Perfect Hashing）**
- **原理**：设计两级哈希函数，确保第一级哈希冲突后，第二级哈希无冲突。  
- **优点**：理论上的最坏时间复杂度为 O(1)。  
- **缺点**：构造复杂，适合静态数据集（如编译器关键字表）。

---

### **总结**
| **方法**       | 适用场景                   | 核心优势          | 主要缺点          |  
|----------------|--------------------------|-----------------|-----------------|  
| 链地址法        | 动态数据，高负载因子       | 实现简单          | 链表过长效率低    |  
| 开放寻址法      | 内存敏感，缓存优化         | 内存紧凑          | 负载因子要求低    |  
| 再哈希法        | 需减少聚集现象            | 冲突分布均匀       | 设计复杂度高      |  



二叉树的**数组表示**主要有以下优点。

- 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。
- 不需要存储指针，比较节省空间。
- 允许随机访问节点。

然而，数组表示也存在一些局限性。

- 数组存储需要连续内存空间，因此不适合存储数据量过大的树。
- 增删节点需要通过数组插入与删除操作实现，效率较低。
- 当二叉树中存在大量 `None` 时，数组中包含的节点数据比重较低，空间利用率较低。
