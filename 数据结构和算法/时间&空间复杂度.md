
### **数据规模与时间复杂度对应表**  
| 数据规模（n）             | 最大可行时间复杂度            | 示例算法                  |     |
| ------------------- | -------------------- | --------------------- | --- |
| $n \leq 10$         | $O(n!)$、$O(2^n)$     | 暴力枚举、全排列              |     |
| $n \leq 20$         | $O(2^n)$             | 状态压缩DP、子集枚举           |     |
| $n \leq 100$        | $O(n^3)$             | 简单动态规划、Floyd-Warshall |     |
| $n \leq 1\text{e}4$ | $O(n^2)$             | 双重循环、朴素动态规划           |     |
| $n \leq 1\text{e}5$ | $O(n \log n)$        | 排序、分治、线段树             |     |
| $n \leq 1\text{e}6$ | $O(n)$、$O(n \log n)$ | 线性遍历、贪心、并查集（路径压缩）     |     |
| $n \leq 1\text{e}9$ | $O(\log n)$、$O(1)$   | 二分查找、数学公式             |     |

---

### **关键原则**  
1. **时间限制估算**：假设每秒处理 $1\text{e}8$ 次运算：  
   - $O(n^2)$: $n \leq 1\text{e}4$（$1\text{e}4^2 = 1\text{e}8$）。  
   - $O(n \log n)$: $n \leq 5\text{e}5$（例如快速排序）。  
   - $O(n)$: $n \leq 1\text{e}8$（需注意空间复杂度）。  

2. **常数优化**：相同时间复杂度下，常数因子可能影响实际表现。例如，递归可能比迭代慢，哈希表可能比数组访问慢。  

3. **空间复杂度**：大规模数据需注意内存限制。例如，$n = 1\text{e}6$ 的二维数组 $\text{int}[1\text{e}6][1\text{e}6]$ 会超出内存。  

4. **特殊场景**：  
   - 预处理（如前缀和）可将 $O(n^2)$ 优化为 $O(n)$。  
   - 贪心或数学方法可能将问题复杂度降至 $O(1)$ 或 $O(\log n)$。  

---

### **实战技巧**  
- **观察数据范围**：题目给出的数据规模直接决定算法选择。例如，$n = 1\text{e}5$ 时，必须使用 $O(n)$ 或 $O(n \log n)$ 的算法。  
- **避免误区**：看似 $O(n)$ 的算法，若含隐藏高复杂度操作（如字符串拼接），可能退化为 $O(n^2)$。  
- **灵活调整**：动态规划的状态转移优化（如斜率优化）、剪枝（DFS/BFS）可降低实际运行时间。  