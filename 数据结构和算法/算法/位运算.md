### **一、基本位运算符**
1. **按位与（AND）** `&`  
   - **规则**：两位都为1时结果为1，否则为0。  
   - **示例**：`0b1010 & 0b1100 = 0b1000`  
   - **用途**：掩码操作（提取特定位）、清零指定位。

2. **按位或（OR）** `|`  
   - **规则**：任意一位为1则结果为1。  
   - **示例**：`0b1010 | 0b1100 = 0b1110`  
   - **用途**：设置特定位为1。

3. **按位异或（XOR）** `^`  
   - **规则**：两位不同时结果为1，否则为0。  
   - **示例**：`0b1010 ^ 0b1100 = 0b0110`  
   - **用途**：交换变量值、数据加密、校验奇偶性。

4. **按位取反（NOT）** `~`  
   - **规则**：所有位取反（0变1，1变0）。  
   - **示例**：`~0b1010`（假设8位）→ `0b11110101`  
   - **注意**：结果与数据类型位数相关（如`int`是32位）。

5. **左移（Left Shift）** `<<`  
   - **规则**：所有位向左移动，低位补0。  
   - **示例**：`0b1010 << 2 = 0b101000`  
   - **用途**：快速乘法（如`a << n`等价于`a * 2ⁿ`）。

6. **右移（Right Shift）** `>>`  
   - **规则**：所有位向右移动，高位补符号位（算术右移）或补0（逻辑右移，视编译器而定）。  
   - **示例**：`0b1010 >> 2 = 0b0010`（假设逻辑右移）  
   - **用途**：快速除法（如`a >> n`等价于`a / 2ⁿ`，整数除法）。

---

### **二、常见应用场景**
1. **位掩码（Bitmask）**  
   - **示例**：用位表示开关状态（如权限系统）：  
   ```cpp
   const int READ = 1 << 0;  // 0b0001
   const int WRITE = 1 << 1; // 0b0010
   int permission = READ | WRITE; // 组合权限
   bool canRead = (permission & READ) != 0; // 检查权限
   ```

2. **交换变量**  
   - **无需临时变量**：  
   ```cpp
   int a = 5, b = 3;
   a ^= b; // a = a ^ b
   b ^= a; // b = b ^ a (此时b变为原a的值)
   a ^= b; // a = a ^ b (此时a变为原b的值)
   ```

3. **快速判断奇偶性**  
   - **奇数的二进制末位为1**：  
   ```cpp
   bool isOdd = (num & 1) != 0;
   ```

4. **高效乘除2的幂次**  
   ```cpp
   int x = 7;
   int doubleX = x << 1; // 14
   int halfX = x >> 1;   // 3（向下取整）
   ```

5. **判断是否为2的幂次**
```cpp
class Solution {
public:
    bool checkPowerOf2(int n) {
        // 检查 n 是否大于 0
        // 2 的幂必须是正数，因为 0 和负数都不是 2 的幂
        // 检查 n 和 n - 1 的按位与操作是否为 0
        // 如果 n 是 2 的幂，则其二进制表示中只有一个 1
        // 例如 2 (10), 4 (100), 8 (1000)
        // 当 n 是 2 的幂时，n - 1 的二进制表示是 n 的最高位 1 变为 0，
        // 其余位从 0 变为 1，例如 2 (10) - 1 = 1 (01), 4 (100) - 1 = 3 (011)
        // 因此 n & (n - 1) 将得到 0
        return n > 0 && (n & (n - 1)) == 0;
    }
};
```

---

### **三、注意事项**
1. **优先级问题**：位运算符优先级通常低于算术运算符，建议用括号明确顺序。  
   - 例如：`a & b == c` 实际等价于 `a & (b == c)`，可能需要写成 `(a & b) == c`。

2. **符号位处理**：右移运算符对有符号数的行为依赖编译器（算术右移或逻辑右移）。

3. **移位越界**：若移动位数超过类型位数（如`int`移动32位），结果是未定义的（UB）。