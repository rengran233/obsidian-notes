## 快速排序：
```cpp
// 数组升序排序
int Partition(vector<int>& arr, int left, int right) {
	int i = left, j = right;
	//终点：i=j
	while (i < j) {
		//先找j后找i，先动j保证最后与基准交换的是一个小于基准数的数
		//从而保证基准数左侧的数都小于基准数
		while (arr[j] >= arr[left] && j > i) j--;
		while (arr[i] <= arr[left] && i < j) i++;
		swap(arr[i], arr[j]);
	}
	swap(arr[left], arr[i]);
	return i;
}

void DoQuickSort(vector<int>& arr, int low, int high) {
	//数组长度为1时终止
	if (low >= high) return;
	int pivot = Partition(arr, low, high);
	DoQuickSort(arr, low, pivot - 1);
	DoQuickSort(arr, pivot + 1, high);
}

void QuickSort(vector<int>& arr) {
	int low = 0, high = arr.size() - 1;
	DoQuickSort(arr, low, high);
}
```


## 单链表归并排序
```cpp
LinkNode* merge(LinkNode* left, LinkNode* right)
{
	LinkNode* dummy = new LinkNode;
	LinkNode* tail = dummy;
	while (left != nullptr && right != nullptr)
	{
		if (left->val < right->val)
		{
			tail->next = left;
			left = left->next;
		}
		else
		{
			tail->next = right;
			right = right->next;
		}
		tail = tail->next;
	}
	tail->next = (left != nullptr) ? left : right;
	return dummy->next;
}

//若链表节点个数为奇数，取中间节点，即将链表分为左长右短两部分
LinkNode* findMid(LinkNode* head) //注意有无哨兵节点
{
	if (head == nullptr || head->next == nullptr) return head;
	LinkNode* slow = head, * fast = head;
	while (fast->next != nullptr && fast->next->next != nullptr)
	{
		slow = slow->next;
		fast = fast->next->next;
	}
	return slow;
}

//若节点个数为奇数，取中间节点的前一个节点
//ListNode* middleNode(ListNode* head) {
//    if (head == nullptr || head->next == nullptr) return head;
//    ListNode* slow = head, * fast = head->next;
//    while (fast->next != nullptr && fast->next->next != nullptr) {
//        slow = slow->next;
//        fast = fast->next->next;
//    }
//    return slow->next;
//}

LinkNode* mergeSort(LinkNode* head)
{
	//返回条件
	if (head == nullptr || head->next == nullptr)
		return head;
	//分割链表
	LinkNode* mid = findMid(head);
	LinkNode* left = head;
	LinkNode* right = mid->next; //此时两链表为无序链表
	mid->next = nullptr;
	//递归
	left = mergeSort(left); //注意接收有序链表
	right = mergeSort(right);
	return merge(left, right);
}
```