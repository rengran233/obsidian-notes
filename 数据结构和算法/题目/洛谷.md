P5717三角形分类：
他解：排序函数找出短边

P1424 小鱼的航程（改进版）:
先计算整周，再处理多余天数

P5720 【深基4.例4】一尺之棰：
可以通过**对数运算**, \[2^n, 2^(n+1))

P1217 \[USACO1.5] 回文质数 Prime Palindromes
**只有奇数可能是质数**

P1423 小玉在游泳
可以用等比求和+取对数

P1075 \[NOIP 2012 普及组] 质因数分解
**唯一分解定理:一个数能且只能分解为一组质数的乘积**

P1047 \[NOIP 2005 普及组] 校门外的树
**线段树/涂色法，标记节点状态**

P2615 \[NOIP 2015 提高组] 神奇的幻方
解0：结构体pos记录坐标，数组vector记录pos
解1：二维数组a\[x]\[y]记录坐标

P2141 \[NOIP 2014 普及组] 珠心算测验
**跳出多重循环：可以使用`flag = true`标记作为条件**
**不重复集合容器`unordered_set`**，头文件`#include<unordered_set>`
错因：重复计数：1.计数重复出现元素2.计数同一元素的不同加和方法
解1：用容器记录目标元素
解2：用足够大的bool数组记录目标元素的状态

P1957 口算练习题
解0：利用string和int的变换`to_string()`和`stoi`

P5735 【深基7.例1】距离函数
简单。错因：使用int类型接收点坐标x，y

P1304 哥德巴赫猜想
错因：没有处理两个相同质数加和的情况

P5739 【深基7.例7】计算阶乘
错因：非void函数必须有返回值

P5740 【深基7.例9】最厉害的学生
错因：`stable_sort()`不能调用重载的`<`
```cpp
bool operator<(const stu& other) const {  // ✔️ 正确写法
    return total > other.total;
}
```

本题存在**精度误差**问题，请将 `a * 0.7 + b * 0.3` 与 80 比较 转化为 `a * 7 + b * 3` 与 800 比较

P1914 小书童——凯撒密码
模运算计算**偏移量**，`+ 'a'`转回字符

P5015 \[NOIP 2018 普及组] 标题统计
`while (cin >> c)` `cin`在读取到`' '`和`'\n'`时跳过，在无输入时返回0

P1308 \[NOIP 2011 普及组] 统计单词数
**大小写匹配：** 可以将字符串全部转换为小写字母
**越界风险：** 用前后空格检查是否为单词，若在头尾容易越界，可在头尾加上`' '`
`string`读取：会将原有内容覆盖，而非拼接
`size_t`类型不能为负数
**边界检查：**
```cpp
bool leftValid = (found == 0) || (text[found - 1] == ' ');
bool rightValid = (found + len == text.size()) || 
					(text[found + len] == ' ');
if (leftValid && rightValid) {}
```

P3741 小果的键盘
错因：需要找到VK并标记

P1321 单词覆盖还原
毫无头绪！
单词被覆盖后一定会保留至少一个字母，则位置不变。并且两单词无重复字母。以此判断连续3或4个字母是否有字母符合原单词分布。

P1553 数字反转（升级版）
注：反转字符串抹去首位0需要用字符`'0'`判断
消首0需特判字符串只有1个元素0的情况，小数还需要抹尾0，小数部分若只有0则不抹

P1205 \[USACO1.2] 方块转换 Transformations
1.`>>`和`getline()`混用的换行符滞留问题
2.`vector`初始化预留空间避免访问空容器

P1319 压缩技术
实现两种循环交替：设置sign，并在循环结束时令`sign = !sign`
解0：将所有数字储存在数组中，然后嵌套循环输出n行n个元素
解1：也可以设置一个计数器，`if(t==n)`换行，更优

P1017 \[NOIP 2000 提高组] 进制转换 （普及-）

P2670 \[NOIP 2015 普及组] 扫雷游戏 （入门）
错因：if嵌套过于复杂。对于if (A) { if (B); if(C) }，可以实现条件A&&B，但是无法实现条件C，如无法计数最右侧地雷正上、正下的格子
解法：循环检测八邻域
```cpp
for (int i = 0; i < r; i++)
	for (int j = 0; j < c; j++)
		if (rec[i][j] == '*')
		{
			cnt[i][j] = -10;
			for (int dx = -1; dx <= 1; dx++)
				for (int dy = -1; dy <= 1; dy++)
				{
					if (!dx && !dy) continue;
					int x = i + dx, y = j + dy;
					if (x >= 0 && x < r && y >= 0 && y < c)
						cnt[x][y]++;
				}
		}
//dx，dy为坐标偏差值，r为行数，c为列数，rec接收地图，cnt计数
```

P1152 欢乐的跳 （入门）
排序加循环比较 / 标记

P1042 \[NOIP 2003 普及组] 乒乓球 （普及-）
模拟，错因：读字符循环方法错误，使用了`getchar()`

P2660 zzc 种田 （入门）
贪心，错因：超时，多次减法等效于一次除法

P1009 \[NOIP 1998 普及组] 阶乘之和
注意默认填充