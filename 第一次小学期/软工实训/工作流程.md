- Core：控制游戏状态，管理游戏更新，发送信号给Graphics模块
- GameObjects：游戏对象，只关注自身的属性和更新，不能影响其他模块
- Systems：在Core中实例化，管理GameObjects的行为，InputSystems还需要和MainWindow协作处理输入
- Graphics：接收Core中的信号，调用Resources获取资源存入缓存，为游戏对象绘制贴图
- Resources：查看assets文件夹获取游戏资源
- UI：与玩家交互
- 理论上游戏逻辑和图形部分只通过Core和Graphics相连，但是为了方便有一处例外
- 出于方便，目前PhysicsSystem的作用其实被分散了，其余部分都十分重要

#### CMake系统
- 根目录管理二级目录TankVerseClient和TankVerseServer
- TankVerseClient中管理各个模块，每个模块都封装成库，并暴露自己的头文件路径
- 各个模块不要忘了链接Qt的库
- main.cpp放在TankVerseClient下，与服务端分隔，创建可执行文件

#### 控制坦克移动
- MainWindow::keyPressEvent()（UI）：窗口与玩家交互，捕获按键
- inputSystem->setKeyPressed()（Systems）：输入系统处理按键事件，转化为方向单位向量
- Tank::setVelocity()、MovableObject::setVelocity()（GameObjects）：坦克实例接收方向
- GameEngine::GameLoop()（Core）：不断循环更新游戏

#### 贴图渲染
- GameEngine发出信号表示新对象创建/对象位置移动
- Renderer调取ResourceManager寻找图像资源，找到后与对象建立映射
- 如果图像不符合tile规格，进行缩放
- 绘制图像并与位置移动

#### 碰撞检测
全在CollisionSystem里，看了就明白了

#### 启动游戏与关卡加载
1. **MainWindow (UI层)** -> 槽函数 onStartButtonClicked() 被触发。
2. **MainWindow** -> 调用 m_engine->startNewGame()，将控制权交给引擎。
3. **GameEngine (Core层)** -> 在 startNewGame() 内部，按顺序执行：  
    a. 调用 clearAllObjects()，清理上一局的所有 GameObject。  
    b. 调用 loadLevel(1)，开始加载关卡。  
    c. 在 loadLevel() 中，通过 new PlayerTank(), new EnemyTank() 等创建所有逻辑对象实例。  
    d. 每创建一个对象，调用 addGameObject(object)，将对象与信号绑定。
4. **GameEngine** -> 在 addGameObject() 内部：  
    a. 将新对象存入游戏对象列表 m_gameObjects。  
    b. 发射 gameObjectCreated(object) 信号，向外界（主要是渲染层）广播新对象的诞生。  
    c. 检查对象是否为Tank，如果是，则**connect** 它的shotFired信号到引擎的handleTankShot槽函数，为坦克绑定开火逻辑。
5. **GameEngine** -> startNewGame() 的最后，调用 m_gameTimer.start()，启动游戏主循环。

#### 子弹发射
- 捕获空格输入，判断冷却时间，如果冷却时间已过则发射
- 发射信号，激活GameEngine::addGameObject()中登记的相应坦克开火
- 在GameEngine中创建子弹对象并在handleTankShot中初始化（子弹速度暂时设置在这里）

#### AI系统
改其他模块时整瘫痪了，大饼没画出来呢。

#### UI
整改中……

#### 地图和美术资源
画饼中……

#### 关于方向与速度：
将方向和速度分开是很有用的，用一个单位向量维护对象的方向，在MovableObject中与速率结合重新得到速度，可以在很多只需要得知方向的情况下免于switch，并且可以扩展得到更多指向方向

#### 相对路径和绝对路径
少用绝对路径

#### **“炮塔转向”的完整数据流链条**
1. **GameWidget (捕获和转换)**
    
    - mouseMoveEvent被触发。
        
    - 将**视图坐标**转换为**场景坐标** (mapToScene)。
        
    - 发射mouseMovedToScenePos(const QPointF& scenePos)信号，携带**场景坐标**。
        
2. **MainWindow (连接)**
    
    - 通过connect，将GameWidget的mouseMovedToScenePos信号连接到GameEngine的aimPlayerTankAt槽。
        
3. **GameEngine (决策)**
    
    - aimPlayerTankAt(const QPointF& scenePos)槽函数被调用。
        
    - 获取player对象。
        
    - 计算从player位置到scenePos的**角度**。
        
    - 调用player->setTurretRotation(angle)。
        
4. **Tank (状态更新)**
    
    - setTurretRotation(qreal angle)被调用。
        
    - 更新成员变量m_turretRotation。
        
    - 发射turretRotationChanged(qreal newAngle)信号。
        
5. **Renderer (视觉更新)**
    
    - 通过connect捕获到turretRotationChanged信号。
        
    - 在槽函数（Lambda）中，找到对应的**炮塔图形项turretItem**。
        
    - 调用turretItem->setRotation(newAngle)。