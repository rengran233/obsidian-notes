在流水线（Pipelining）处理器设计中，**冒险（Hazards）** 指的是由于某些限制，导致流水线无法在下一个时钟周期执行下一条指令的情况。

流水线冒险主要分为 **三大类**：结构冒险、数据冒险和控制冒险。

---

### 1. 结构冒险 (Structural Hazards)
**定义：** 由于硬件资源不足，导致多条指令在同一时刻争抢同一个物理资源。
*   **常见场景：**
    *   **访存冲突**：如果处理器只有一个存储器（冯·诺依曼结构），取指令（IF）和读取数据（MEM）都需要访问内存。当一条指令在取指，另一条在读数据时，就会撞车。
*   **解决方案：**
    *   **资源重复**：增加硬件。例如，现代 CPU 采用哈佛结构，将 L1 Cache 分为 **指令 Cache** 和 **数据 Cache**，让取指和访存互不干扰。
    *   **停顿（Stall）**：让后来的指令等一等。

---

### 2. 数据冒险 (Data Hazards)
**定义：** 指令之间存在数据依赖关系，后一条指令需要使用前一条指令尚未产生的结果。

数据冒险细分为三种（重点是 RAW）：

#### ① 写后读 (RAW, Read After Write) —— **最常见**
*   **场景：** `add x1, x2, x3` 后面跟着 `sub x4, x1, x5`。`sub` 要读 `x1`，但 `add` 还没写回。
*   **解决方案：**
    *   **前递（Forwarding/Bypassing）**：直接把运算结果从 EX 或 MEM 阶段拉回 ALU 输入。
    *   **停顿（Stall）**：如果是 Load-Use 冲突（`lw` 后接 `add`），必须停顿一拍再前递。

#### ② 读后写 (WAR, Write After Read) —— **反依赖**
*   **场景：** `sub x4, x1, x5` 先读 `x1`，`add x1, x2, x3` 后写 `x1`。
*   **结论：** 在基础的**顺序执行五级流水线**中不会发生，因为读总是在写之前。只在乱序执行 CPU 中出现。

#### ③ 写后写 (WAW, Write After Write) —— **输出依赖**
*   **场景：** 两条指令连续往同一个寄存器写值。
*   **结论：** 在顺序流水线中不会发生（后写的总会覆盖先写的）。只在乱序执行或长短不一的流水线（如浮点运算）中出现。

---

### 3. 控制冒险 (Control Hazards)
**定义：** 也叫“分支冒险”。处理器在取指阶段不知道下一条指令该取哪一条（因为分支指令的结果还没算出来）。

*   **常见场景：** 执行 `beq`、`bne`、`jal` 指令时。
*   **解决方案：**
    *   **停顿（Stall）**：最笨的办法，确定了跳不跳再取指。
    *   **分支预测（Branch Prediction）**：猜一个方向先跑着。猜对了零延迟，猜错了清空流水线（Flush）。
    *   **延迟槽（Delayed Branch）**：在分支指令后强行执行一条无关指令（早期 MIPS 常用，现在较少见）。

---

### 总结对照表

| 冒险类型 | 核心矛盾 | 关键词 | 主要解决方法 |
| :--- | :--- | :--- | :--- |
| **结构冒险** | 硬件资源不够用 | 抢资源 | 增加硬件（双 Cache）、停顿 |
| **数据冒险** | 数据还没算好就要用 | **RAW** | **前递 (Forwarding)**、停顿 |
| **控制冒险** | 下一条该取谁不知道 | 分支/跳转 | **分支预测**、清空流水线 |

**一句话总结：**
*   **结构**是“没地方用”；
*   **数据**是“没东西用”；
*   **控制**是“不知道用谁”。