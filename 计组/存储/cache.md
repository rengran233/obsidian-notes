### 5.2 存储技术

按**存储层级**划分：
1. 寄存器
2. cache高速缓存（SRAM）
3. 内存（RAM）
4. 外存/辅存（磁盘等）
按**物理技术**划分：
- RAM
	- SRAM：快而贵，常用于cache
	- DRAM：慢而便宜，常用于内存
- ROM
- 闪存（SSD）：从EEROM发展来，但已不属于传统ROM范畴
- 磁盘（HDD）

### 5.3 cache基础

cache被划分为$2^n$个数据块，每个数据块有m个字节。对于访问的地址addr，cache会对其直接取模`addr mod n`，即用地址的低位作为其映射在cache中的编号。剩余的高位会作为`tag`标签记录来区分映射编号相同的地址。cache在初始化时所有的`valid`字段都为N，只有被访问过一次后才会变为Y并记录相应的数据

提高cache中块的数量，可以降低冲突失效的可能，从而降低失效率
提高一个数据块中存储的字数，可以更好地利用空间局部性一次加载更多内容
权衡：块大小在64B达到最低失效率

#### 5.3.2 失效处理

如果不同时满足tag匹配且valid为1，读/写操作即为失效。读操作必须等待内存返回数据并写入cache，而写操作

### 5.4 性能评估与改进



#### 5.4.1 替换策略优化

替换策略分为三种：
- 直接相联：将一个物理地址取模映射为唯一对应的数据块
- 全相联：一个物理地址可以映射到cache中的任何位置，减少冲突失效发生
- 组相联：折中做法，将n个块分为一组，先取模找到

#### 5.4.2 多级cache优化

将cache分为多个层级，在上层没有命中则立刻访问下层，失效代价就从访问主存的时间变为了访问下层cache的时间。这样每个层级的关注点可以不同，比如L1专注于减少访问时间而L2专注于降低失效率避免访问主存。


#### 1. 计算完美命中情况下的性能提升

分别计算指令缓存和数据缓存因失效浪费的时钟周期，然后和完美命中情况下消耗的时钟周期对比

#### 2. 

### temp

cache与主存之间的读写操作以块为单位，而CPU与cache的读写操作以字/字节为单位

4KiB cache意味着其包含的数据量为4KiB=$2^{12}$Bytes，但cache还需要额外空间存储元数据（如tag、valid）

就算访存失效，在计算时间时也要算上本次访存的命中时间