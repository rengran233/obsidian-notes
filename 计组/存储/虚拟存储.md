### 5.7 虚拟存储

虚拟存储是即为每个程序的存储需求**单独分配逻辑地址**，再由TLB和页表映射为物理地址访问。

考虑虚拟存储，访存的时间将分为：**虚拟地址翻译**+**物理数据读写**两个部分。虚拟地址翻译为物理地址后，将从cache开始比对

发生缺页意味着CPU需要的虚拟页在页表中没有对应的物理页，说明物理页没有被分配完或者虚拟页比物理页更多，所以在物理页被占满后还有没有对应物理页的虚拟页。

页被挪到磁盘上说明内存中的物理资源不够了，说明给进程分配的物理页超出了内存大小或者有多个进程同时在使用内存空间

*页内偏移的位数$n$决定了页的大小$N=2^n$，需要覆盖一个页中的所有字节*
*虚拟页号的位数$m$决定了虚拟页的数量$M=2^m$，也是页表项的数量*
*虚拟地址的位数即$a=m+n$*
*页表项的大小为$P$，页表的大小为$M\times P$*
*虚拟地址空间即虚拟地址可以映射到的空间，其大小为$M\times N=2^a$* 

| 物理量 | 符号/公式 | 备注 |
| :--- | :--- | :--- |
| **页内偏移位数** | $n$ | $2^n = \text{页大小}$ |
| **虚拟页号位数** | $m$ | 对应 $2^m$ 个虚拟页 |
| **虚拟地址总位数** | $a = m + n$ | CPU 发出的地址总宽度 |
| **虚拟地址空间** | $2^a$ 字节 | 程序能访问的最大理论范围 |
| **物理页号位数** | $ppn\_bits$ | 取决于实际内存条能插多大 |
| **页表项大小 $P$** | $\approx (ppn\_bits + \text{控制位}) / 8$ | **常取 4B 或 8B 以实现对齐** |
| **线性页表总大小** | $2^m \times P$ | 必须连续存放在内存中 |

#### 5.7.2 缺页失效

虚拟页的数量总是大于物理页，这样当物理页数量不足时，可以将不常用的页**转移到磁盘**Swap区上，并将磁盘地址存在没有对应物理地址的页表项上

通过定期清除引用位近似实现LRU
页表必须包含对应空间中的所有页表项，如果空间使用率很低，可以使用多级页表

增大页体积可以让TLB覆盖更大的空间，降低失效率；让页表体积减小。但是因为每个程序分配到的内存大小都是页的整数倍，大页（如给2MiB的程序分配了1GiB）会造成浪费
