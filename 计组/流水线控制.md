
为什么说在同时读写时寄存器堆内部实现了前递：逻辑上实现，通过时钟上下沿分别执行读写

更深的流水线可以拆解指令，提高指令吞吐率；同时减少最长指令的执行时间，提高时钟频率

---

## 一、 控制的基础：从单周期到流水线

### 1. 本质区别
*   **单周期 CPU**：控制信号在ID阶段产生，在整个周期内有效。
*   **流水线 CPU**：控制信号在ID阶段产生，必须通过打包跟随指令传递到后续阶段。
*   **如果不传递会发生什么？**（请用自己的话描述）：
    * 控制信号在ID阶段产生，先执行的指令将使用后执行指令的控制信号

### 2. 控制信号的生成
*   **输入**：控制单元（Control Unit）的输入是指令的哪一部分？（提示：RISC-V 指令的 Opcode 字段）
    *   *____________________*
*   **输出**：在 ID 阶段，控制单元一次性生成了所有信号。此时需要根据生效阶段将它们分为三类（见下节）。

---

## 二、 控制信号的分组与传递（核心背诵点）

*(建议对着书上图 4.51 填写)*

### 1. EX 阶段使用的信号（Execution）
*   这些信号存入 `ID/EX` 寄存器，在下一周期使用。
*   **RegDst (RISC-V无此信号，但需理解)** / **ALUSrc**：决定 ALU 的第二个操作数是来自____还是____？
*   **ALUOp**：告诉 ALU 执行什么运算（加、减、与、或...）。
*   *在此处补充其他 EX 级信号：____________________*

### 2. MEM 阶段使用的信号（Memory Access）
*   这些信号存入 `ID/EX` -> `EX/MEM` 寄存器。
*   **MemRead**：是否从内存____数据？
*   **MemWrite**：是否向内存____数据？
*   **Branch**：如果是 `beq` 指令，该信号为 1，用于控制____。

### 3. WB 阶段使用的信号（Write Back）
*   这些信号传递路径最长：`ID/EX` -> `EX/MEM` -> `MEM/WB`。
*   **RegWrite**：是否需要写入____？
*   **MemtoReg**：写入寄存器的数据是来自____还是____？

---

## 三、 数据冒险的硬件控制：前向通路 (Forwarding)

*(参考书上图 4.53)*

### 1. 前向单元 (Forwarding Unit)
*   **位置**：位于流水线的____阶段。
*   **输入信号**（它需要比较哪三个寄存器编号？）：
    1.  当前指令的源寄存器：`ID/EX.RegisterRs1` 和 `ID/EX.RegisterRs2`
    2.  前一条指令的目标寄存器：`______________.RegisterRd`
    3.  前前条指令的目标寄存器：`______________.RegisterRd`
*   **控制逻辑**（用伪代码描述）：
    *   如果 `EX/MEM.RegWrite` 为真 且 `EX/MEM.Rd == ID/EX.Rs1`，则发生____冒险。
    *   **动作**：将 ALU 的输入 A 选择为来自____（旁路数据）。

### 2. 停顿单元 (Hazard Detection Unit) - 处理 Load-Use
*   **位置**：位于流水线的____阶段。
*   **检测条件**：
    *   上一条指令是 `Load` 指令（即 `ID/EX.MemRead` 为真）。
    *   且上一条指令的 `rd` 等于当前指令的 `rs1` 或 `rs2`。
*   **动作**（如何制造一个“气泡/Bubble”？）：
    1.  控制信号多路选择器：将 ID 阶段发出的所有控制信号置为0。
    2.  PC 寄存器和IF/ID寄存器：保持不变。

通过前递解决冒险：
- 前递单元一般放在EX阶段
- EX和MEM两个阶段对应了两种**距离**的冒险
- EX阶段：R型、I型算术和跳转链接指令已经在ALU产生了结果，此处的冒险发生是因为后一条指令请求了将写的寄存器
- MEM阶段：MEM阶段没有写寄存器操作，此处的冒险发生是因为后后一条指令请求了将写的寄存器，ALU的结果存储只是在MEM/WB寄存器中**路过**MEM阶段
- 加载指令需要在MEM阶段访存后才能产生结果，EX阶段时只产生了地址，后后一条指令可以通过前递来获取写入的数据，但后一条指令不能由前递解决
通过停顿解决冒险：
- 通过ID阶段的冒险检测单元提前发现Load-Use冲突
- 让流水线空转一个时钟周期

ForwardA的三个可选项：00-RS1、10-ALU的结果（EX阶段冒险）、01-访存的结果（MEM阶段冒险）
ForwardB的三个可选项：RS2、ALU的结果、访存的结果
```python
# 1. 首先判断是否存在 EX 冒险 (距离为 1 的相邻指令)
if (EX/MEM.RegWrite == 1 and EX/MEM.rd != 0 and EX/MEM.rd == ID/EX.rs1):
    ForwardA = 10  # 优先级最高：选择 EX/MEM 寄存器中的数据

# 2. 只有在 EX 冒险不满足时，才去检查 MEM 冒险 (距离为 2 的指令)
elif (MEM/WB.RegWrite == 1 and MEM/WB.rd != 0 and MEM/WB.rd == ID/EX.rs1):
    ForwardA = 01  # 选择 MEM/WB 寄存器中的数据

# 3. 如果都没有，则不前递
else:
    ForwardA = 00  # 正常从寄存器堆读取
```
隔一条指令的冒险输出一定是01，紧邻指令的冒险输出一定是10，双重冒险输出最新的数据（10），Load-Use冒险不会发生在紧邻指令